####
# Parser.
####

p = Parser()

p.parse(args = None)
p.parse_known(args = None)
p.help_text(section = None)
p.error_text()
p.warn(msg)
p.error(code = None, msg = None))
p.exit(code = None, msg = None)

####
# Opts.
####

o = Opt(
    option     = '--job-id',            # Or string-spec with option, aliases, and arg_name.
    aliases    = ['-j', '-J', '--jid'], # Or just one string.
    n_args     = 1,
    repeatable = False,                 # If true, append values.
    choices    = ('A', 'B', 'C', 'D'),
    required   = False,
    tolerant   = False,                 # Setting option makes grammar fully tolerant.
    high       = False,                 # A high-precedence option (eg --help).
    greedy     = True,                  # Affects options arg consumption.
)

####
# Examples.
####

p = Parser(
    # Via simple Opt.
    Opt('--since TERM', type = int, default = 123),
    Opt('--limit N', type = int, default = 0),
    Opt('--rebuild'),
    Opt('--experiment EXP'),
    Opt('--stats'),
    Opt('--month M'),
    Opt('--search TERM', repeatable = True),
    Opt('--get ITEM'),

    # Via full Opts.
    Opt(
        'task',
        choices = 'configure submit upload start get stop download find'.split(),
        desc    = 'The odin-client task to run',
    ),

    # Via dict.
    dict(
        option  = '--odin-env ENV',
        groups  = 'general',
        default = 'dev',
        desc    = "Odin environment ('production' for most users).",
    ),

    parsing_config = {
        allow_abbrev = True,
        opt_prefix_rgx = ...,
    },

    formatter_config = {
        program_name = '...',
        etc ...
    },

)

# All help-text section, in order.
p.help_text()

# Specific help-text sections, in the requested order.
p.help_text('usage')
p.help_text('section-foo')
p.help_text('section-foo', 'section-bar')


####
# SimpleSpec.
####

For example:

    --verbose --type A <x> <y> -h -g

    spec = '-n NAME --foo --bar B1 B2 <x> <y>'
    p = parser(simple = spec)


    expr        = (longoption | shortoption | posarg)+

    longoption  = longopt optarg*
    shortoption = shortopt optarg*
    posarg      = "<" char+ ">"

    longopt     = "--" char+
    shortopt    = "-" char
    optarg      = [A-Z_\-\d]+
    char        = [\w\-]

Elements:

    short opt  | -h
    long opt   | --type
    opt arg    | A
    positional | <x>


Example: from spec to Opt() instances to parsing logic:

    Spec:

        -n NAME --foo --bar B1 B2 <x> <y>

    Opt instances:

        -n      nargs=1
        --foo
        --bar   nargs=2
        x
        y

    Parsing logic:

        # Initial grammar.
        grammar = n | foo | bar | x | y

        # Keep parsing until we have used all grammar elements.
        while grammar.has_elements():
            parse
            if the ParsedOpt we got is not repeatable:
                grammer = grammar - that Opt

####
# GrammarSpec.
####

For references in my notes, let's refer to this example script as blort-maker.

For example:

    general`      : [--verbose] [--log-file {}]
    other`        : [--hi] [--bye]

    configure     : general` ; task=configure! --odin-env {} --od-user {}
    submit        : general` ; task=submit! -c {} -r {} [--start-job] [--person {name} {age}]
    get           : general` ; task=get! -j {} [--json [--indent {}] | --b64 | --yaml]
    drop          : general` ; task=drop! what=(first|last|random)! [--print] <n>
    fubb          : [-a] [-b] other` <fubb>... (--fast | --slow)
    zzz           : [-x] [-y] other` (<a> <b> <c> [-z]){2,7}
    help          : --help*

Naming:

    short opt
    long opt
    opt arg
    positional
    variant
    partial
    destination
    literal
    option group name
    zone

Overall structure:

    foo` : PARTIAL_DEFINITION
    bar  : VARIANT_DEFINITION

Variant definition syntax:

    Variants and zones:

        foo`      Insert the "foo" partial definition.
        ;         Divider between zones.
        !         Anchor item(s) to the front of a zone.

    Grouping and alternatives:

        []        Grouping, optional.
        ()        Grouping, required.
        |         Alternation.

    Quantifiers:

        ...       Repetition: 1+ or 0+ depending on brackets or question mark.
        {m,n}     Repetition: m through n, inclusive.
        ?         Non-greedy quantifier.

    Options:

        -x           Short.
        --xy         Long.

    Positional arguments and option arguments:

        <xy>      Positional.
        {xy}      Named option argument.
        {}        Unnamed option argument.

    Literals:

        foo=bar   Literal arg (bar), assigned to "foo" in results.
        bar       Literal arg, not assigned in regults (eg, for separators).
        'bar'     Literal arg, when it conflicts with grammar punctuation.

    Special options:

        *         High precedence option: if present, do a best-effort parse
                  and dispatch to a callable rather that executing the
                  normal program or halting on bad input.

Notes about the `zzz` variant:

    - A sequence of options/positionals can be occur 2 to 7 times.

    - If the -z option is provided by the user at a repeated-group boundary,
      we attach it to the first group eagerly.

    - For example:

        # Input.
        A1 B1 C1 -z A2 B2 C2      # -z with first group

        # ParseOption info.
        a : [A1,   A2]
        b : [B1,   B2]
        c : [C1,   C2]
        z : [True, False]

Notes about varying positionals:

    - Only 1 positional can occur a variable N of times.

    - Otherwise, we cannot allocate the values unambiguously.

    - For example, all of these are ambiguous:

        <a>... <b>... <c>
        <a>...{3} <b> <c>...{2} <d>
        (<a> <b>... <c>){2}

    - Varying positionals can be used with an option taking a
      varying nargs, provided that a reasonable parsing approach
      is used and users arrange their command-line arguments
      to avoid ambiguity.

Notes on --help:

    - This example is premised on the idea that we are aiming for
      the following:

        frob --help              # Print general help.
        frob configure --help    # Print help for the configure task.

    - But how does the user configure this help dispatching. More generally,
      what about supporting other help-printing scenarios that rely not on
      `--help` but on some other options: for example, I've had programs where
      I want --examples to print some usage examples for the end-user.

        - Simple use case: standard help feature for a CLI program.

            p = Parser(help = True|False)

        - Help hook for ultimate flexibility: any time the library's help
          feature is triggered, call the user's function with some params and
          let them return something to tell the library which help section to
          print, if any. This approach is probably powerful, but it does not
          speak to simple use cases (standard help) or the most common type of
          complex use case (a program with subcommands, where the subcommands
          and help sections have a 1:1 correspondence).

            p = Parser(help = CALLABLE)

        - To support help dispatching base on subcommands.

            - Simple configuration:

                o = Opt('task', help = USE_SECTIONS)

                - Set the Opt's help param to a constant provided by the
                  library. If set, this tells the library to use the parsed
                  value of the Opt to select the help section whenever help is
                  triggered.

            - More flexible configuration:

                o = Opt('task', help = DICT)

                - The user maps the task values to help section names.

Named and unnamed option arguments:

    Positionals must be named:

        frob <a> <b> [<c>]

    Option arguments can be named or unnamed:

                                            # Value of parsed data in user code:
        frob --mode {group} {name} {n}      # - Data object with attributes.
        frob --mode {} {} {}                # - Tuple.

Another usage example, based on my recent neck-diagram script:

    The grammar:

        main :  (
                    cmd=snum   <snum>             |
                    cmd=fnum   <fnum>             |
                    cmd=number numbering=(on|off) |
                    cmd=tuning <notes>...         |
                    cmd=fret   <syms>...          |
                    cmd=invert <syms>...
                )...

Possibly useful feature to support via API:

    - Variant validation.

    - Maybe, but most validation is already covered by Opt validation.

    - And we should orchestrate that code to give users enough contextual
      information so that their validation code for one Opt can access
      any other Opt values.

Variants: are they needed?

    - Why do the variants have names? More broadly, are they really needed if
      we have alternation?

    - Some not-especially-good reasons:

        - Ability to refer to partials by name. This seems true, but
          we could solve partials a different way.

        - Better error reporting. Maybe, but you only need to report info
          about the variant if variants exist.

        - As a convenience for common subcommand use cases, help text could
          be linked to variant names in an automatic way. Maybe, but it
          probably makes more sense to do help-dispatch via the Opt rather
          than the variant.

Separators:

    - Consider the nab use case.

        - Here we have a linear sequence commands:

            nab grep <> [-c] / split <> <> / item 1 / print

        - Because we don't know in advance what args the commands (grep, split,
          etc) will take, we need a command separator. The command names are
          not sufficient as separators, because some commands might have
          arguments with the same names.

    - How would the user convey the separators in the grammar? I think
      a partial would work:

        cmd` :  (
                    cmd=chomp                          |
                    cmd=findall <rgx>                  |
                    cmd=grep <rgx> [-i] [-v] [-s]      |
                    cmd=range <start> <stop> [<step>]  |
                    cmd=run <code> [-g {}] [-a]
                )

        main : cmd` [ / cmd` ]...

    - That seems plausible, but how would returned data be organized?

        - In this case we have a quantified variant? That's new.

        - Two problems:

            1. We need to link the repeated cmd to a name in the returned data.

            2. And somehow the library needs to know that the first cmd and the
            optional sequence of separator-plus-cmd should be unified under the
            same collection in the returned data.

        - This starts to seem awkward, but the first issue could be solved by
          generalizing the storage-target naming convention we already have.
          Let any element (or group of elements) in the grammar take a target
          name.

            - For example:

                main : config=([--size {}] [-x] [-z]) run=(<paths>... [--overwrite])

                In returned data:

                    opts.config : Data(size, x, z)
                    opts.run    : Data(paths, overwrite)

            - The nab use case:

                main : commands=(cmd` [ / cmd` ]...)

        - That might work but it's getting very complex visually. It this
          a case where the underlying API should do the work?

Variants: other possible features:

    - Unnamed variants: in the neck-diagram example, the 'main' variant
      isn't doing anything useful.

    - Sub-variants.

        - That might seem like extra complexity, but it might not alter the
          difficulty by very much. We already have a tree-based approach for
          the grammar. Sub-variants just an a new level in the recursion.

        - Do we have any known use cases for subvariants? Not directly,
          but the neck-diagram example is suggestive. For example, take
          neck-diagram as an example, but add more restrictions:

            config` : (
                        [cmd=nfrets <nfrets>]
                        [cmd=tuning <notes>...]
                      )


                        cmd=fnum   <fnum>             |
                        cmd=number numbering=(on|off) |
                        cmd=fret   <syms>...          |
                        cmd=invert <syms>...
                    )...

            main :  (
                        cmd=snum   <snum>             |
                        cmd=fnum   <fnum>             |
                        cmd=number numbering=(on|off) |
                        cmd=tuning <notes>...         |
                        cmd=fret   <syms>...          |
                        cmd=invert <syms>...
                    )...

Simple spec vs grammar spec:

    - Is this separation needed?

    - Just convert simple spec to the official syntax

        # Instead of this.
        -n NAME --foo --bar B1 B2 <x> <y>

        # Do this.
        -n {} --foo --bar {} {} <x> <y>

    - And then allow the grammar to use variants (the complex case) or not.

Grammar via API:

    blort-maker:

        general_opts = Partial(
            'general',
            Opt('--verbose'),
            Opt('--log-file {}'),
        )

        other_opts = Partial(
            'other',
            Opt('--hi'),
            Opt('--bye'),
        )

        task_opt = Opt(
            'task',
            choices = ('configure', 'submit', 'get', 'drop'),
        )

        general_zone = Zone(general_opts)

        variants = [
            Variant(
                'configure',
                general_zone,
                Zone(
                    Choice(task_opt, value = 'configure', anchor = True),
                    Opt('--odin-env {}', required = True),
                    Opt('--od-user {}', required = True),
                ),
            ),
            Variant(
                'submit',
                general_zone,
                Zone(
                    Choice(task_opt, value = 'submit', anchor = True),
                    Opt('-c {}', required = True),
                    Opt('-r {}', required = True),
                    Opt('--start-job'),
                    Opt('--person {name} {age}'),
                ),
            ),
            Variant(
                'get',
                general_zone,
                Zone(
                    Choice(task_opt, value = 'get', anchor = True),
                    Opt('-j {}', required = True),
                    Alternatives(
                        Group(
                            Opt('--json', required = True),
                            Opt('--indent {}'),
                        ),
                        Opt('--b64'),
                        Opt('--yaml'),
                        required = False,
                    ),
                ),
            ),
            Variant(
                'drop',
                general_zone,
                Zone(
                    Choice(task_opt, value = 'drop', anchor = True),
                    Opt('what', choices = ('first', 'last', 'random'), required = True),
                    Opt('--print'),
                    Opt('n'),
                ),
            ),
            Variant(
                'fubb',
                Opt('-a'),
                Opt('-b'),
                other_opts,
                Opt('fubb', nargs = (1, None)),
                Alternatives(
                    Opt('--fast'),
                    Opt('--slow'),
                ),
            ),
            Variant(
                'zzz',
                Opt('-x'),
                Opt('-y'),
                other_opts,
                Group(
                    Opt('a'),
                    Opt('b'),
                    Opt('c'),
                    Opt('-z'),
                    ntimes = (2, 7),
                ),
            ),
            Variant(
                'help',
                Opt('--help', high = True),
            ),
        ]

