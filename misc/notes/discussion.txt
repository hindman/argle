--------
why-optopus: Why Python needs a better command line argument parser
--------

INTRODUCTION

    [Don't concede so much. Optopus is superior: easier, more efficient,
    more powerful. Critize current tools for their heavy APIs. Show
    comparative examples. Lead with common advantages. Then expand to
    show additional powers.]

    To varying degrees of success, command-line argument parsing libraries
    generally do a reasonable job handling the most common use cases. They are
    able to parse garden-variety command-line inputs and provide help text to
    end users. Some libraries also take partial steps toward supporting a
    larger set of features, such as basic conversion and validation, varying
    numbers of optional parameters or positional arguments, mutually exclusive
    options, subcommand-style programs like git, and occasionally a small
    amount of help text customization or the ability to control error handling.

    But those additional features tend not to go very far. At least in the
    languages I have worked in extensively (currently Python, previously Ruby
    and Perl), argument parsing libraries satisfy roughly 80 to 90 percent of
    the most common use cases, but cause frustration or hassle for any needs
    that are complex, specialized, unusual, or merely particular.

    Optopus aims to fill that void by providing a library that is powerful,
    flexible, and highly customizable -- all without sacrificing intuitiveness
    and practicality. Indeed, the library will be able to handle not only
    complex or atypical needs, but will also reduce developer hassle for the
    most common and simplest usage patterns.

    The library is under active development and a beta release has been
    published. The purpose of that release was mainly to reserve the project
    name in pypi.org, but it already provides useful functionality not
    currently available in other libraries -- namely, no-configuration parsing,
    which is quite handy for quick-and-dirty, temporary, or experimental
    scripts that require nothing more than open-ended support for flags and
    positionals.

        # Install the library in the usual way.

            $ pip install optopus

        # Write almost no code.

            from optopus import Parser

            p = Parser()
            opts = p.parse()

            # The returned data object supports attribute access,
            # key access, membership testing, and iteration.
            print(opts)
            print(opts.bar)
            print(opts['x'])
            print('others' in opts)
            for name, value in opts:
                print((name, value))


        # Try it out.

            $ python foo.py --bar A B C -x D
            Result(bar=True, x=True, others=['A', 'B', 'C', 'D'])
            True
            True
            True
            ('bar', True)
            ('x', True)
            ('others', ['A', 'B', 'C', 'D'])

    With that introduction, what are the primary problems with the currently
    available argument parsing libraries and how will Optopus do better?

WEAK GRAMMARS

    Most argument parsing libraries start from the simplest model of
    command-line usage: an ordered sequence of positionals along with an
    unordered set of short and long options that can be freely mixed among the
    positionals and that can take zero or more ordered parameters. That basic
    framework is sometimes extended to support mutually exclusive options and
    subparsers (the latter for programs that need a subcommand style).

    The argparse library is a representative example in this vein: it does a
    reasonable job for common use cases but struggles with command-lines that
    require a grammar falling beyond the typical. On stackoverflow and the
    Python bug tracker, for example, one can find a variety of desired and
    generally sensible use cases that argparse cannot support at all or can
    support only partially after some uncomfortable hackery.

    The most frequently desired grammatical features fall into the following
    buckets:

        - Mutual exclusion beyond the simplest case. The argparse library
          supports mutual exclusion among options considered individually. But
          it cannot apply that type of requirement to groups of options (for
          example, -x OR -y -z).

        - Conditional requirements or exclusions. The argparse library does
          offer subparsers as one mechanism to apply conditional requirements,
          but this seems like an awkward and heavy device for what are often
          fairly simple grammatical needs (for example, if -x then require -y
          or -z; or if -a then -a is not allowed).

        - Logical relationship among options (for example, at least one of: -a
          OR -b OR -a -b).

        - More flexible quantification. The argparse library supports four
          basic quantifiers (N, ? *, and +), but it lacks support for ranges,
          which can arise in a variety of plausible uses cases. There is no
          strong reason not to support them.

        - More complex repetition. The argparse library can apply quantifiers
          to individual options or positionals, but not to groups (for example,
          two positionals, <x> <y>, repeatable in pairs). Sometimes the group
          that needs to be repeated is the full command-line grammar. In fact,
          I am working on such a program: a Python tool for quick text
          transformation pipelines in the spirit of sed/awk/perl, but with more
          intuitive usage, a built-in set of core utilities, and an easy
          mechanism for users to add their own. Because the tool is literally a
          pipeline for text running through various conversion and computation
          stages, it makes sense to model the command-line grammar as
          repeatable. This use can is mostly supportable by cobbling together
          multiple argparse parsers, but it is awkward and requires a bit of
          special logic.

        - Parameter or argument independence. When an option has multiple
          parameters or a positional has multiple arguments, most argument
          parsers force them to be configured indentically. But sometimes
          independence makes sense (for example, -a {A,B,C} {X,Y}, where each
          parameter has different choices).

    Optopus addresses those and other needs by adding the missing grammatical
    pieces: groups as first-class citizens, the full set of regular expression
    quantifiers, support for alternatives, and in the same vein, alternative
    usage variants that can be triggered in a variety of ways.

    In spite of its power, that flexible grammar will be intuitive to use
    because it builds on widely familiar conventions for program usage text,
    along with a limited number of syntax enhancements (most of them inspired
    by regular expressions). Here is an example grammar for a program with two
    usage variants (named Add and Delete) triggered by the value of the <task>
    positional ('add' or 'delete'), along with a third variant allowing the
    user to request some help text showing examples.

        Add      : <task=add> (<name> <id>)...
        Delete   : <task=delete> <id>{1,5} [--date {}] [--log [--json [--indent] | --xml]]
        Examples : --examples

    Defining command-line grammar via a configuration syntax inspired by usage
    text is not a new idea. While most argument parsing libraries are like
    argparse in configuring the parser's grammar via a programmatic API, some
    libraries take a different approach: the user writes the help text
    (sometimes enhanced with special syntax elements), the parser is derived
    from that text, and the text (minus any special syntax) is used as the
    literal usage and help text presented to end users. Examples include docopt
    in Python or Getopt::Long::Descriptive, Getopt::Euclid, and Getopt::Declare
    in Perl.

    My experiments with argument parsing libraries convinced me that both
    approaches have their strengths and weaknesses. Optopus builds on the
    strengths:

        - Use a text syntax to define the core: the grammar and logical
          relationships, along with the names to be used when referring to
          options, parameters, positionals, groups, and usage variants. Those
          are the areas where the text-driven approach shines. Consider the
          example grammar shown above: it conveys a lot of information very
          efficiently and intuitively when compared against what most
          API-driven libraries would require of the user (and none of them
          could fully support the example). In spite of those benefits, most
          programmers do not want to handcraft the end-user-facing usage and
          help text if a computer program can do it consistently and well (not
          to mention dyntamically responding to terminal width or to runtime
          configurations). That is why Optopus takes substantial inspiration
          from, but does not fully adopt, the ideas motivating the text-driven
          parsers: Optopus treats the text as a configuration syntax, not
          literal usage text.

        - Use the programmatic API to apply other configurations: defaults,
          conversion, validation, aliases, short description text for each
          option or positional, and various other details. The API approach
          excels in these areas. The Optopus library builds on the strength of
          the API approach and adds some additional conveniences -- most
          notably, a bulk configuration mechanism -- to keep the developer
          burden as low as possible.

    Finally, it should be noted that all of the library's behaviors will be
    configurable via the API, including the grammar -- not merely to satisfy
    traditionalists, but because, at least for simpler use cases, configuring
    the parser's grammar via the API also works well. Users are free to select
    whichever approach suits their preferences or their program's needs.

INFLEXIBILITY

    In addition to having an insufficiently powerful grammatical foundation,
    existing argument parsers tend to be inflexible in their design
    and thus not open to very much customization.

    Three areas are noteworthy:

        - Help text and error text. Most libraries offer only limited controls
          over the formatting, arrangement, and style of help and error text.
          Argparse, for example, offers a few subclasses that adjust help text
          in small ways or allow the user to supply regular text blocks that
          will be presented as-is rather than line wrapped. But the underlying
          HelpFormatter class is not friendly to customization generally. Some
          of its stylistic choices seem non-standard or inelegant to my eye and
          I've never found ways to adjust them without awkward hacks. More
          fundamentally, the library is not prepared to handle bigger changes,
          ranging from fairly standard needs (for example, help text in
          man-page format) to more innovative approaches. Optopus will offer
          some of those approaches directly with the aim of giving programmers
          the ability to light-up and improve the readability of help text. One
          simple example is listing option aliases (for example, --foo might
          have an alias of -f) in a separate section to avoid overburdening the
          options section of the help text. Another is supporting the ability
          to refer to groups of options by symbolic names in the usage text, a
          technique that can greatly enhance the readability of usage text for
          programs with a large number of options. An example:

                buy-car [style-options] [engine-options] <make> <model>

        - Side effects. Many argument parsers, including argparse until Python
          3.9, are rigid in response to invalid input. They start with sensible
          default behavior: in the face of bad input, print brief usage text
          and an error message, then exit. But they turn that default into a
          requirement by providing no good way to prevent the side effects from
          occurring (by good way, I mean one where the library would include
          sufficient contextual data about the error, rather than just
          providing the error text string). That default behavior works in the
          most common cases, but sometimes programs have other needs. Argument
          parsing libraries should follow ordinary best practices by giving the
          user the ability to bypass or postpone major side effects like
          printing and exiting. Imagine any other data oriented library doing
          that.

        - Parsing modes. Existing libaries tend offer the ability to parse only
          the known arguments, but they rarely venture beyond that. One
          possiblity is to relax other parsing rules, with an eye toward
          parsing as much input as possible in order to glean end-user intent
          to provide a more meaningful help. Another is to support
          no-configuration parsing modes that will parse any input based on
          standard rules and return a data object. The purpose is to support
          low-stakes or temporary scripts that could benefit from a
          command-line option or two, but are not important enough to warrant
          very much configuration work. Optopus will eventually offer three
          varieties of no-config parsing. Finally, it is worth emphasizing the
          power of the grammar syntax in quickly defining a command line in
          low-stakes situations. With two lines of code a developer can parse
          arguments for a wide variety of simple scripts. A simple example:

            p = Parser('<host> <port> [--verbose] [--size {} {}]')
            opts = p.parse()

    To the extent that the existing libraries do allow customizations, the
    mechanisms for doing that are sometimes awkward. Argparse is a good
    example: many workarounds to user difficulties with the library involve
    subclassing, but most argparse classes do not appear to be well-designed
    for inheritance (and some of their docstrings seem to discourage it
    outright). At a minimum, one a can say that the library does not provide
    authoritative guidance on which classes are amenable to subclassing, if
    any, and what users should do or avoid when doing so.

    Optopus will be built with an eye toward flexibility and customization. To
    the extent feasible, all controllable parameters governing the generation
    of text will be adjustable. And for dynamic configuration needs -- whether
    related to help text, error text, side effects, or parsing -- the library
    will support them via hooks rather than subclassing. Developers needing
    special behavior will not have to worry whether they have implemented a
    method override robustly enough in the face of edge cases or future
    evolution of the library. Instead, they will just have to write an ordinary
    hook function based on a documented API.

UNHELPFUL HELP

    - griping instead of helping

        - high precedence

    - special help sections

    - sometimes awkward usage text

        - API generated usage and help text can be awkward -- visually
          confusing or overbearing -- at times, especially when they list every
          possible usage pattern exhaustively or when the number literal
          choices (for parameters or positionals) is moderate-to-large in size.

        - Better techniques are available. Some of them arise due
          from usage variants or from treating groups as first-class
          citizens in the grammar.

INSUFFICIENT DEVELOPER SUPPORT

    - missing utilities

        - Argument parsers are all used in the same general context:
          command-line programs.

        - Those programs have many common needs during the early phase of the
          program where arguments are parsed and validated.

        - Optopus aims to help developers by providing several of the
          needed utilities:

            quitting with proper exit codes, sometimes after printing
            a warning or error message.

            hanlding --version

            supporting hidden (developer-only or "super user" only) options

            flexible mechansims for argument conversion, validation,
            and dispatching.

    - missing good cooperation with config files and env variables

        - Complex programs often have command-line options and arguments,
          but they also want their end-users to be able to set their
          default preferences in configuration files and/or variables.

        - An argument parser need to support that use case conveniently.

    - nested destinations

    - sometimes heavy configuration apis

        - bulk config

            - In most cases it's easier to configure options individual.

            - But in some situations, code can be make lighter and more
              readable by applying configurations to multiple options at once.
              Optopus will support this alternative through a convenient
              mechanism.

        - convenience syntax when defining the grammar through the API.

            Compare, for example how one would configure a single option
            taking 2 parameters in argparse vs Optopus.

                # Argparse.
                p.add_argument('--foo', nargs = 2)

                # Optopus.
                p.opt('--foo _ _')

            Or an option with choices:

                # Argparse.
                p.add_argument('--foo', choices = ('A', 'B', 'C'))

                # Optopus.
                p.opt('--foo A|B|C')

            Or an option with two required parameters and one optional
            parameters, each having different choices. Because Argparse cannot
            handle this scenario, the example compares and API-driven
            configuration of the option vs a text-driven one. Optopus supports
            both approaches, but the comparison illustrates the expressiveness
            and ease of the grammar syntax compared to API usage.

                # Via API.
                p.opt('--foo', nparams = (2, 3), choices = [('A', 'B'), ('M', 'N'), ('X', 'Y')])

                # Via grammar syntax.
                p.opt('--foo A|B M|N [X|Y]')

--------
api-vs-text: API-driven vs text-driven
--------

Two fundamental configuration strategies for argument parsers:

    - API-driven:

        - User configures a parser via the programmatic API.
        - The parser generates the help text.
        - Typically allows user to override with literal help text, if desired.
        - Examples: argparse and many others.

    - Text-driven:

        - User writes usage and options text.
        - Library derives the parser from that text.
        - This approach is much less common.
        - Examples: docopt.

The optopus library combines the best of both approaches:

    - API-driven.

        - Tends to require less typing.

        - Generated usage text is mostly fine, especially for simpler projects.

        - Most developers probably prefer an API-driven approach over
          hand-formatting help text themselves.

        - API-generated help text will follow the conventions for documenting
          command-line programs -- conventions that few developers have studied
          in depth and would rather not worry about.

    - Text-driven for grammar and naming:

        - Even though my experiments configuring argument parsers of varyig
          complexity via usage text convinced me of the benefits of an
          API-driven approach, text-driven option parsers have notable
          advantages. Those advantages are focused on command-line grammar and
          the associated naming for parsed data returned to the caller.

        - The text-driven approach emphasizes the idea of usage variants, a
          technique that can greatly enhance usage-text readability --
          especially for complex programs but also for small ones.

                git diff [<commit>] [--] [<path>...]
                git diff --cached [<commit>] [--] [<path>...]
                git diff <commit> <commit> [--] [<path>...]

                frob [--debug] [--foo <f>] <path>...
                frob --help
                frob --version

        - Usage variants open up a range of possibilities in the kinds of
          command-line grammars that can be supported. API-driven parsers
          struggle with command-lines that need any grammar falling beyond the
          most typical cases. On stackoverflow and bugs.python.org, for
          example, one can find many command-line use cases (some of them quite
          simple) that are not supported easily by argparse but that are
          straightforward in docopt.

        - Finally, usage syntax is both efficient and intuitive. When internet
          users discuss command-line grammar scenarios, they invariably use a
          usage syntax to specify the desired grammar. In my own research, I
          experimented with defining the needed grammars via an API, but I
          consistently found the text-based approach simpler to express and
          read. [For a good example, see this argparse discussion where a user
          describes a problem in general terms and suggests how the argparse
          API could be augmented to handle such cases -- and the discussion
          both are somewhat difficult to understand without very careful
          reading and thinking. Then the user provides a short one-line usage
          syntax, and the issue is immediately clear.
          https://bugs.python.org/issue11588]

Configuration via usage syntax is focused on grammar:

    - Optopus keeps that syntax fairly clean, readable, and intutive by
      focusing it solely on the grammar and naming -- the area where it excels.
      Other details, if any are neeeded, are handled via the API.

    - The syntax is also intuitive because it relies heavily on common
      conventions for documenting command-line programs.

    - The syntax will look roughly like familiar usage text, plus a small
      number of additional syntax elements focused on supporting flexible
      command-line grammar.

          - Usage variants. Discussed above.

          - Partial variants, which use the variant concept to define a named
            group of options and/or arguments that can then be inserted into
            one or more usage variants -- avoiding repetition in the definition
            of complex grammars (argparse does this via parents).

          - Named destinations for any group of elements in the grammar.

    - The syntax opens up a wide range of possibilities for complex programs or
      unusual grammars

    - But it also helps at the micro scale, simplifying the configuration of
      individual options.

--------
other-lib-weaknesses: Addressing weaknesses common in other libraries
--------

Providing users with simple ways to handle command-line grammars and usage
variants (just noted).

Supporting everything from quick-and-dirty scripts to complex, highly
customized command-line programs:

    - At once extreme, optopus allows you to parse any default-behavior
      command line, with zero configuration. Just import and go. This parser
      won't enforce any rules, but it will tell you what the end-user entered
      -- which is good enough for many types of quick-and-dirty scripts,
      debugging sessions, experiments, and even early prototypes.

            import optopus
            opts = optopus.parse_args()

    - At the other extreme, you could build the next Git or a variety of
      programs with idiosyncratic grammars, heavily customized help text, and
      many other features.

    - Sitting between the two extremes are numerous conveniences and sensible
      defaults to make option parsing easy, no matter what level of control
      your application needs.

Allowing users to control the generated help text in a fine-grained manner.

    - Program complexity increases the need to organize and fine-tune help
      text, but not necessarily to write and layout the whole thing
      (text-driven libraries require that).

    - Optopus provides many mechanisms for that fine tuning:

        - Simple top-level configurations to control basic layout,
          capitalization, punctuation, etc.

        - Ability to group options into sections.

        - Ability to supply hand-crafted sections whenever needed and to locate
          those sections with precision in the output.

        - Ability to control nearly all parameters driving the help text
          contruction process via configuration and, where necessary, through
          the programmatic hooks. There should be no need to subclass optopus
          or delve into the parser's innards.

        - Support for common styles: command-line vs man-page.

Allowing users to enhance usage-text readability by being able to refer to
groups of options and to omit either short or long options.

    - API-generated usage text tends to be poor not only because it lacks usage
      variants but also because the generated text exhaustively lists all
      options in all of their permutations (short and long).

    - Especially as the number of options grows, readability can be improved
      greatly by referring to sets of options by symbolic names rather than by
      enumerating every possibility.

    - Similarly, readability can be enhanced by focusing the usage text on just
      the long-options (or just the short-options) and then providing a mapping
      between short and long options latter in the help text.

Allowing users to define their arguments and options in ways that encourage
modularity.

    - In optopus a user defines/configures options and arguments as atomic
      units, separate from the issues of command-line grammar, usage variants,
      and options help text.

    - Each of those atomic units can be attached to one or more groups of
      related options.

    - Then those options or option-groups can be leveraged when defining the
      command-line grammar, when expressing the generated usage text, and when
      organizing the options text into sections.

Providing users with full access to the parser configuration, both via the API
and in the form of standard, serializable data structures.

Providing users more conventient mechanisms to reduce repetition in
the configuration of the parser.

--------
other-goals: Other goals
--------

Prioritize the simple use cases. Yes, add features and customization
capability. But do that without sacrificing super super usage patterns.

Usage should be intuitive and declarative, especially for the simplest and most
common use cases. It should not depend on bizarre syntax or on user-created
complex data structures.

The parser's configuration should be expressible as a data structure -- and
creatable from one. This is important for testing, debugging, easy integration
with config files, and using other libraries for data validation.

For complex programs or special needs, users should have full control over
documentation. This includes both usage/help text and the styling of error
messages.

Easy system for validators to be combined flexibly.

Should easily support different help types: (a) brief usage/synopsis, (b) full
help or man-page, and (c) extras or examples.

Include ability to merge options from several sources: ENV variables, config
files, command-line options. Note that the purpose of the configuration sources
(ENV vars and config files) is to set the default values used by the
command-line option parser. When defaults are supplied, it should also cause a
required option to become non-required (in other words, whenever default is set
for an option, it causes required to become False.

Make it easy to test the option parser.

Error handling should be under the user's control, if they want it. This is a
serious flaw in some parsers (eg argparse). The library should support both
"automatic" mode (where the parser will eagerly print help or error message and
then exit) or non-automatic mode (where the parser will simply return an object
containing all information and allow the user to decide what to do. [Note that
argparse has addressed this, in whole or in part, in Python 3.9].

Should have a design that is friendly to customization. Allow users to
customize by writing simple functions or hooks rather than having to subclass.
Consider using the pluggy library so that users can implement simple function
hooks.

Start simple: begin with core behaviors; don't support more flexibility until a
basic working system is in place.

Where possible, rely on convention over configuration: sensible defaults to
allow the most common path to be followed with minimal setup.

Provide good support for --version. Show the application's name and version
number.

Provide helper functions for warn(), exit().

Support various configuration styles: per option configuration (argparse and
many other libraries do this); and thematic or bulk (make one type of setting
on multiple options at once).

Allow the user to have hidden options (eg for developers only).

Support file and dir types as arguments, with checks for existence or non-existence.

For file path arguments, support the ability to treat `-` as stdin or stdout.

Support an easy way to get bash completion.

Support @somefile.txt: user supplies command-line args via a file.

Support parse_known_args().

Support abbreviated option names when there is no ambiguity.

Support some no-configuration argument parsing strategies: default (options are
flags), key-val (options take single args by default), greedy (options consume
as many params as possible).

Support conversion/validation.

Support dispatch mechanisms.

The parser's configuration is likely to be organized as a fairly deep tree
behind the scenes. But make it easy for the user to query that tree to obtain
nodes of interest for configuration and other purposes. Primarily this means
quickly getting Opt instances, but there could be other types of interest as
well.

Let users control the important aspects of the help text: section ordering;
section titles; layout style (eg, compact 2-column or man-page); capitalization
rules; widths; conventions for showing default values; etc.

--------
standard-cli-grammar: Standard command-line grammar
--------

Typical rules of command-line grammar, as commonly understood in Unix tradition:

    - Options start with a prefix:

        --long
        -s

    - Options can take zero or more ordered parameters.

    - Positional arguments are ordered among each other:

        P1 P2 P3 ...

    - Options can be ordered in any way:

        --x4 --x1 --x3 --x2 ...

    - Options can be freely interspersed among the ordered positional arguments.

        --x3 P1 --x1 --x4 P2 --x2 P3 ...

    - Short options can be bundled:

        -x -y -z
        -xyz

--------
cli-grammar-vs-regex: Command-line grammar vs. regex
--------

Although Optopus usage syntax borrows many concepts from regular expressions,
command-line grammar parsing is not readily amenable to handling via regex
parsing approaches.

Positionals are ordered among themselves, but options can appear in any order
(ignoring boundaries and anchors). That flexibility makes it not very intuitive
to convert a command-line grammar into a manageable regular expression. At
every stage, any of the options are possible. But then once an option appears,
it cannot appear again (ignoring repeatables). That means command-line parsing
is context-sensitive.

--------
subparsers-not-needed: Optopus does not need the subparser concept
--------

The subparser concept is much less powerful and flexible than the key concept
of a command-line grammar, along with the related ideas of usage variants and
flexible destination assignment. It's also less intuitive.

The universe of command-line programs could be broken down into a sizable
majority and two small minorities:

    - A sizable majority that needs neither subparsers nor a complex grammar.

    - A small minority that align conceptually with the subparser concept. But
      command-line grammar supports this use case even better.

    - A small minority that are forced by the limitations of current argument
      parsing libraries to resort to subparsers even though the concept does
      not align very well with their needs.

--------
opt-action-not-needed: Optopus does not need the action concept
--------

Arguments can be configured in argparse with an 'action' parameter. The
parameter is a bit overloaded and misleading. It does control some actions (eg,
showing help text), but mostly it is used as a sometimes misnamed device for option type
and destination assignment.

    Action       | Option type       | Example         | Stored      | Notes
    ----------------------------------------------------------------------------------
    store_true   | 1 flag            | --frob          | True        | True == 1
    store_false  | 1 flag            | --frob          | False       | To override a True default
    count        | 1+ flags          | -v -v           | N           | .
    store        | Single            | --foo F         | F           | .
    append       | Repeatable single | -x A -x B       | [A, B]      | Overwrite on repeat
    extend       | Repeatable multi  | -x A B -x C D E | [A B C D E] | .
    help         | High precedence   | .               |             | .
    version      | "    "            | .               | .           | .
    ----------------------------------------------------------------------------------
    store_const  | 1 flag            | --frob          | X           | Not necessary
    append_const | 1+ flag           | --frob --frob   | [X x]       | Not necessary

--------
explicit-option-param-syntax: Why explicit syntax for option parameters is needed
--------

Imagine that the grammar did not require explicit surrouding markers for
parameters, positionals, and literal values: {}, <>, an ''. Every type of
confusion would be possible.

    frob --type x y z   # Meaning of x, y, z unclear.

Some ways to address that problem:

    - Minimize syntax burden. Require that literals be quoted (because rarely
      needed) and positionals use angle brackets (because it is conventional).

    - Enforce consistency: require all 3 types of markers (and because braces
      for params are also conventional).

    - Be creative: require that literals be quoted and give users a mechanism
      to disambiguate when needed. Probably a bad idea: these issues can be
      tricky to think through. Also, for non-standard grammars, a small bit of
      extra typing seems easy compared to having to reason about subleties.

--------
high-precendence-options: High precedence options
--------

Most options control the primary behaviors of a program. But some are
special, most notably those related to user help:

    --help
    --version
    --examples
    --demo

Argument parsing libraries often provide an convenient mechanism for --help and
sometimes --version, but rarely anything else. In addition, they tend to
provide such features in a way that is slightly misleading (at least in a
strict sense) and definitely not as convenient for users as it could be.

Consider a simple subcommand-style program. Assume that both <id> and the
parameter for -n should be integers and that the program has both general help
text and subcommand help text.

    demo [--help] [-n {}] (print|delete) <id>

At least by default, if the end-user supplies the --help option, an argument
parser should (1) print help text and exit, (2) select the help text that is
relevant given the other command-line arguments, and (3) ignore errors in the
other command-line arguments. Some examples of desired behavior:

    demo --help                # General help.
    demo --help delete         # Delete help.
    demo --help -n HI delete   # Same, in spite of invalid -n parameter.

Most argument parsers fail on #3 (they gripe instead of helping) and they do
not easily support #2.

Optopus addresses those problems with two mechanisms: high-precendence options
and flexible dispatching. If an option is configured to be high-precendence,
its presence among the command-line arguments will trigger whatever action it
has been configured to perform, and that dispatching configuration will take
precendence over error reporting. When high-precendence options are used, the
parser performs a best-effort parsing to collect as much contextual information
as it can before calling the code responsible taking action.

There are limits, of course. Some types of bad input can reduce the accuracy of
that best-effort parse. In this example, -Q in an unknown option and is treated
by default as a flag taking no parameters, which then means that HI is is
interpretted an invalid subcommand.

    demo --help -Q HI delete   # General help rather than delete help.

--------
help-text-formatting: Help text formatting
--------

Text wrapping:

    - Respect terminal widths, if known and within boundaries:

        min_width = 40
        max_width = 100

    - Allow users to adjust those parameters.

    - User-supplied text:

        - Break into paragraphs (but preserve info about N of blank lines
          between paragraphs).

        - Rewrap to the desired width (probably using textwrap module).

        - Leave indented paragraphs as-is.

        - Provide an easy syntax for users to suppress line wrapping
          within the text (eg something borrowed from markdown)

Option parameters:

    - Avoid the typical verbosity of API-based help text. By default,
      use a compact notation for parameters:

        [--foo {}] [--bar {}] [--bazz {} {} {}]

    - Let users set their own defaults too:

        p = Parser()
        p.defaults(metavar = 'X')

--------
grammar-parsing-algo: Parsing the grammar syntax
--------

New notes:

    - need to be able to peek farther ahead:

        - in grammar section, an opt-help line can look like a variant line
          for a few tokens, until the colon

        - outside the grammar section, the same thing can occur: line
          looks like opt-help until some token other than colon occurs

    - thus, need prev-peeks deque, rather than just self.curr

    - might need to emit whitespace from lexer, because some syntax rules
      impose whitespace requirements.

    - the deque offers two approaches:

        - better peek tools:
            - peek that returns token(s) rather than bool
            - peek_until(X)
            - peek(X)                # Look for [WHITESPACE...] X
            - peek(X, exact = True)  # Look for X

        - barf():
            - eat freely within a single handler, holding tentative tokens
            - but if that path fails non-fatally, call barf(toks) to put them in deque again

    - track more, possibly things like:
        - paragraph num
        - paragraph type (text or empty)
        - indent of the line the token started on
        - the line itself

    - advanced peek/barf solutions probably not needed for section markers,
      because we can use high-precendence tokens like the following:

        section-name
        section-title
        blockquote-regular
        blockquote-syntax

    - To create the section help text:

        - The ParseElem coming from a section will be line-oriented.
        - Blank and other lines are rendered as-is.
        - OptHelp lines are generated via the derived configuration.

Phase 1: input normalization:

    - Accept text and/or lines of text.
    - Join into a block of text.

Phase 2: separate grammar section from other sections:

    - The grammar section differs and other sections differ in their handlers
      and possibly tokens.

    - The other sections will use line-oriented ParseElem: SectionTitle,
      BlankLine, OptHelp, and OtherLine.

    - So parsing a spec will make two SpecParser.parse() calls.

Phase 3: lexing:

    - Remember that the lexer analyzes character by character to emit
      a flat streem of the meaningful atomic units of the language.

    - It does not engage in validation logic to assess whether the arrangement
      of those units is syntactically valid.

    - Nor does it try to assemble those character-based atoms into fully
      meaningful entitities, other than in cases where they must be assembled
      to avoid ambiguitity with similar tokens.

Phase 4: parsing:

    - A parser's job is to eat a stream of tokens, organizing them into
      meaningful and valid units, and emitting those units to the caller.

        - Previously, I tried to write the lexer code with a parsing mindset.
          That was too hard.

        - Now we just have to figure out how to organize the consumption of the
          tokens listed above.

    - Focus now on the full grammar. Convenience syntax can be handle later via
      a different subclass, different tokens, different handlers, or
      some combo.

    - Handlers should be substantive from the perspective of the
      language, not low level.

    - Since a grammar is just a sequence of Variant (no longer true: other
      possibility is OptHelp), there will be just one handler. The more
      fine-grained method calling will occur in the subclass.

    - See draft.py for draft of the handlers and some related
      changes to RegexLexer.

Phase 5: assembly:

    - The parser phase is the most complex, so don't overburden it with the
      duty of creating the ultimate grammar elements.

    - Instead, keep the parser simpler by having it emit simple AST-style
      objects.

    - The last phase converts the AST to true grammar elements.

--------
convenience-parsing-algo: Parsing the convenience grammar syntax
--------

The grammar can be built from the parts we already have:

    P1         = positional | positional_definition
    P2         = [ P1 ]

    O1         = short_option | long_option
    O2         = parameter | parameter_definition
    O3         = [ O2 ]

    single_pos = P1+ P2*
    single_opt = O1 O2+ O3*

Apply extra validation at the end to disallow:

    Only a single Opt (if P1 repeats, they must have same dest).
    Group
    PositionalVariant
    ParameterVariant

To orchestrate things we can adjust the SpecParser initializer:

    def __init__(self, text, single = False):
        self.lexer = RegexLexer(text, GRAMMAR_TOKENS)
        if single:
            self.parser_functions = (self.single_pos, self.single_opt)
        else:
            self.parser_functions = (self.variant,)

--------
arg-parsing-algo: Parsing algorithm
--------

Notation and terminology:

    - Purely notational concepts:

        Pos:         A positional Opt.
        MGroup:      A Group having mutex=True.
        Alternative: A Variant or MGroup.
        OPT:         When current arg looks like an Opt.
        POS:         When current arg looks like a Pos.

    - Parsing terms:

        - Alternatives: the Variants and MGroups determine how many
          alternatives we will try.

        - Interpretations: within an alternative, there can be multiple valid
          interpretations of the arguments -- specifically how they are
          allocated to Opts either as positionals or params.

        - Backtracking terms:

            - Current interpretation or parsing route: the interpretation you
              are currently on, based on a successful parse of the current arg.

            - Foregone interpretation: the interpretation that you could have
              selected, but did not -- so you push it to the stack before proceeding
              with the current interpretation.

Some key insights related to backtracking:

    - Parsing decisions that might require backtracking come from positional
      arguments or parameters, not options. Options, if present, are
      non-ambiguous: either they are known and allowed, or not.

    - Backtracking is needed when your current parsing route ends up attaching
      a param to an Opt or an argument to a Pos but then that route ultimately
      fails (on a later argument). You need to backtrack to check any foregone
      alternative interpretations of the input arguments.

    - Alternative interpretations are possible only for Opt with non-static
      nparams, Pos with non-static nargs, or Pos with non-static ntimes.

    - So pushing to the stack needs to happen when your parsing decision for
      the current argument creates a foregone alternative.

    - This occurs only for successful parsing of the current argument; never
      for errors.

    - Variants and MGroups also don't require a backtracking mechanism.

        - Rather, you want to process all of the alternatives in order, based
          on the Grammar. Each alternative either succeeds or fails. And you
          stop on the first success.

        - The best time to load the stack with these alternatives is before the
          while-stack loop begins. This will ensure that each alternative will
          be tried in order. Because we are using a stack, backtracking within
          any specific alternative (due to non-static nparams/nargs) will
          finish before the algorithm advances to a fresh alternative.

        - If you were to try to push foregone interpretations to the stack when
          an alternative fails, you interfere with the correct ordering of the
          alternatives. Perhaps even worse, it's not easy to know within the
          while-stack loop when an alternative has totally failed. Each
          iteration of the loop can be either starting a fresh alternative or
          exploring one of the different interpretations possible within the
          alternative.

A backtracking example:

    Grammar:
        Opt('-f', nparams = (1,3))
        Opt('x', nargs = (3,4))

    Input:
        -f V1 V2 V3 V4 V5

    Parsing logic:

        -f : Valid: attach it to Opt(-f).

        V1 : Attach to Opt(-f)

        V2 : Because Opt(-f) is greedy by default, attach. But
             this attachment is not required due to non-static
             nparams. Before pushing the new State where V2
             is attached to Opt(-f), we should push the foregone
             interpretation -- namely, where we restrict Opt(-f)
             to nparams of (1,1).

        V3 : Same logic: attach and push foregone interpretation.

        V4 : Attach to Opt(x).

        V5 : Same.

        -  : Now we're out of arguments and have not
             satisfied Opt(x). So this interpretation fails.
             The next State in the stack will restrict
             Opt(-f) to nparams of (2,2), which will succeed.

    Logic if Opt(-f) had been non-greedy.

        V2 : Don't attach to Opt(-f). Now the foregone interpretation
             is for Opt(-f) with nparams of (2,3). Push that
             to the stack.

State:

    - Data object to hold parsing state as the various interpretations from the
      grammar are being tried during the while-stack loop.

    - Attributes:

        ai: index of args.

        next_pos: next available Pos [or None].

        nps: nparams remaining for the active Opt [or None].

        avail: map of available Opt to remaining ntimes [0 for exhausted].

        target: Target instance holding parsed data accumulated so far.

        err: error that terminated the current alterantive [or None].

        variant: name/id/index for the current variant; relevant for
        error selection/reporting, not parsing directly.

ArgResult:

    Data object to represent info need to capture the result-so-far
    for the parsing the current arg. Some likely attributes:

        err: data object holding error info
        opt: matched Opt
        val: converted value

    Notation used here:

        ArgResult(ERR: ...) | Current arg failed.
        ArgResult(OPT)      | Current arg matched OPT.
        ArgResult(PARAM)    | Current arg matched PARAM.
        ArgResult(POS)      | Current arg matched POS.
        ArgResult(UNKNOWN)  | For forge-ahead-mode or parse-known-mode.

How to handle optional Groups:

    - A Group can be optional overall, but have required elements if
      the Group is triggered by the presence of any of its elements.
      For example, if either -x or -y are present, both are needed.

        [ -x -y [-i] ]

    - When to handle such matters:

        - During parse. For example, when we see -x, then we would
          immediately adjust ntimes for -y.

        - After a successfull ArgResult. Before checking Opts for sufficient
          nparams, nargs, ntimes, we would first adjust those expectations
          based on any Groups that were activated by the presence of the Opts.

    - The latter, for two reasons:

        - Groups can alter quantifier expections. It makes sense to do all of
          that quantifier checking together.

        - More fundamentally, an optional Group can contain positionals and
          params. Like in the rest of the grammar, greedy is the default. That
          means positionals within optional Groups should be attached eagerly.
          It could get very messy trying to support some special logic just for
          optional Groups. The user has multiple ways to configure the grammar
          if the default greediness isn't desired.

Algorithm: setup:

    Stuff from the end-user or user:

        args = [...]

        P = Parser(...)
        G = P.grammar

    Initialize the stack that drives the algorithm. For every allowed combo of
    Variant and MGroup, add a State instance to represent the initial
    conditions of each alternative.

        # The stack of States.
        stack = [S1, S2, ...]
        stack = list(reversed(stack))

        # Every State examined and whether the entire parse is complete.
        history = []
        success = False

        # Parser-wide inventory of all known OPT.
        known_opts = G.get_all_options()

Algorithm: parsing loop:

    while stack and not success:

        # Prep.

        S = stack.pop()
        arg = args[S.ai]
        T = P.get_arg_type(arg)
        ares = ArgResult()

        # Check arg type.

        if T is OPT:

            # Handle aliases and fuzzy match.
            if arg not in S.avail:
                arg = P.fuzzy_match(arg)

            if arg not in known_opts:
                ares = ArgResult(ERR: globally unknown OPT)
            elif arg not in S.avail:
                ares = ArgResult(ERR: inapplicable OPT)
            elif S.nps is not None:
                ares = ArgResult(ERR: expected param but got OPT)
            elif S.avail[arg] == 0:
                ares = ArgResult(ERR: OPT occurred too many times)
            else:
                ares = ArgResult(OPT)

        else:
            if S.nps[arg]:
                ares = ArgResult(PARAM)
            elif S.next_pos is not None:
                ares = ArgResult(POS)
            else:
                ares = ArgResult(ERR: too many POS arguments)

        # Conversion and validation for PARAM and POS.

        if not ares.ERR and not ares.OPT:
            null = object()
            val = null
            ok = null
            err = None
            try:
                val = ares.opt.convert(arg)
                ok = ares.opt.validate(val)
            except (...) as e:
                ares.err = captured info about the error

            if ok is not True and (forge-ahead-mode or parse-known-mode):
                # Treat as success.
                ares.best_effort = True
                ares.val = arg
            elif val is null:
                ares = ArgResult(ERR: conversion raised an error)
            elif ok is null:
                ares = ArgResult(ERR: validation raised an error)
            elif ok is False:
                ares = ArgResult(ERR: validation returned False)
            else:
                # Success.
                ares.val = val

        # Handle less restrictive parsing modes.

        if ares.ERR and (forge-ahead-mode or parse-known-mode):
            ares = ArgResult(UNKNOWN)

        # Check for overall success if args exhausted.

        if ares.ERR is None and S.ai + 1 == len(args):

            - First check whether any Groups have been activated by the present
              Opts. If so, adjust expected ntimes accordingly.

            - Then check that all Opts have sufficient nparams, nargs, ntimes.

            if OK:
                success = True
            else:
                ares = ArgResult(ERR: insufficient ntimes/nparams/nargs)

        # Store history, push foregone, check overall success.

        if ares.ERR:
            # On error, just store the history.
            S.target.add(ares)
            history.append(S)

        else:

            # Check for foregone interpretation.
            # Not yet sure if we should perform these steps for ArgResult(UNKNOWN).
            if not success and (ares.PARAM or ares.POS):
                If either of these apply:
                    - Matched Opt has non-static nparams.
                    - Match Pos has non-static nargs or ntimes.
                Then:
                    S2 = new State to represent the foregone parsing route
                    stack.push(S2)

            # Store history.
            S.target.add(ares)
            history.append(S)

            # Create next parsing State.
            S1 = new State based on current parsing route
            stack.push(S1)

Algorithm: wrap up:

    if success:
        return history[-1].target

    else:
        - Examine history to find most relevant error.
        - Return or raise, depending on Parser configuration.

Post-parsing logic:

    target = self.do_parse(...)

    Load the data from target into a Result. Details will vary based on Parser
    configuration and parsing-mode.

--------
alternative-parsing-algo: Alternative parsing algorithm won't work after all
--------

The algorithm:

    - When parse() is called, there will be N command line arguments.
      Command-line use cases never have large N.

    - Using the parser configuration, assemble data on the aspects of the
      grammar that are not static. The most common non-static configurations:
      varying nargs, nparams, or ntimes; variants; and alternatives.

    - For grammar elements that have no inherent boundaries (eg, an option
      taking 1+ params), interpret them in as bounded by using N as the upper
      limit.

    - Use all of that information to generate all static grammars that satisfy
      the actual grammar.

    - Check each static grammar against the command line arguments.

    - A successful parse finds exactly one successful static grammar.

What causes a grammar to generate multiple possibilities?

    .                     | Where expressed | Note
    -----------------------------------------------------
    Varying nargs/nparams | Opt             | .
    Varying ntimes        | Opt or Phrase   | Includes required.
    Alternatives          | Phrase          | Includes variants.
    Aliases               | Opt             | .

Benefits of the algorithm:

    - This code seems easy to write:

        - The generation of static grammars seems like a manageable
          situation involving itertools.

        - Parsing a static grammar very simple: no backtracking required.

    - It provides a run-time guard for users against ambiguous grammars.

Three concerns:

    - The approach seems non-standard. A classic stack algorithm seems to suit
      the situation. And that code might not be any harder to write -- perhaps
      just a bit less familiar. Why reinvent the wheel? Make sure there's a
      good reason.

    - Modern operating systems and shells have very large limits on the max
      size of command lines and N of arguments. Why build a good argument
      parsing tool that would fail at moderate values for N -- especially
      when a linear algorithm is known?

    - There won't necessarily be only one successful parse of the static
      grammars, as noted in the discussion of ambiguous grammars. By using a
      greedy assignment policy the parser can ignore that matter. But regular
      expressions have a greedy concept precisely because without it there can
      be more than one successful parse of an input. [On further reflection,
      this point argues against expecting only one successful static grammar.
      But if you try the static grammars in the correct order, based on greedy
      policies in place, you can stop at the first success -- as regex does.]

--------
ambiguous-grammars: Ambiguous grammars are not an issue
--------

From a strictly grammatical perspective, only one positional can have a
non-static nargs or ntimes, because there isn't exactly one valid way to attach
the values to the destination attributes. A similar problem occurs when an
option has non-static nparams and a positional has non-static nargs.
Two examples:

    <xray>...    <y>...
    --xray {}... <y>...

But that's not a problem, because Optopus can do what regular expression
engines do: greedy assignment by default, non-greedy by configuration.

--------
parsed-data-structure: Parsed data structuring: nargs, nparams, ntimes
--------

The meaning of nparams, nargs, and ntimes:

    nparams : N of params (for options)
    nargs   : N args (for positionals)
    ntimes  : Governs only optionality and repetition via {n,m} or its shortcuts.

    Options:                    #  nparams  ntimes

        -y                      #  0        (1,1)
        [-y]                    #  0        (0,1)
        [-y {} {}]              #  2        (0,1)

    Positionals:                #  nargs    ntimes

        <x>                     #  1        (1,1)
        [<x>]                   #  1        (0,1)
        (<x> <x> <x>){0,2}      #  3        (0,2)
        -----------------------------------------
        <x> <x> <x>             #  3        (1,1)      # A
        <x>{3}                  #  1        (3,3)      # B

Is nargs needed? Why not handle it all with ntimes? See the examples marked A
and B above. There is a subtle difference between the two configurations in the
returned data, if the user requests non-flattened. Example A would produce [X1,
X2, X2], but example B would create [[X1], [X2], [X3]]. Generally, users should
prefer to configure positionals with nargs first, using ntimes only when
required.

Internally, all data assigned to destinations will be stored in a fully
explicit manner. Assume a list of lists, where nargs/nparams determines the
length of the innermost lists and ntimes determines the length of the outer
list(s).

    - Singular nargs, nparams, and ntimes:

        a1     # Either value or bool (latter if nargs/nparams is zero).

    - Add plural nargs/nparams:

        [a1, a2, ...]

    - Add plural ntimes:

        -x _ _ (<z> <z>){3}

        x = [a1, a2]

        z = [[a1, a2], ..., ...]

    - Add a layer of nested plural ntimes:

        (  --foo _ _  (-x _ _ <z> <z>){3}  ){4}

        foo: nparams 2, ntimes     4
        x  : nparams 2, ntimes 3 x 4
        z  : nargs   2, ntimes 3 x 4

        foo = [[a1, a2], ..., ..., ...]

        x = [
            [[a1, a2], ..., ...],
            ...
            ...
            ...
        ]

        z = Same structure as x.

Default flattening policy:

    - If the grammar does not contain nested plural ntimes, data
      will be flattened as much as possible, as shown in table below.

    - User can request non-flattened data or flattened (the latted
      to flatten even the 2x2 or nested scenarios).

    nargs or | ntimes    | ntimes 2+                   | ntimes 2+
    nparams  | 0 or 1    | Flattened                   | Non-flattened
    ------------------------------------------------------------------
    0        | bool      | [bool, ...]                 | [[bool], ...]
    1        | a1        | [a1, ...]                   | [[a1], ...]
    2+       | [a1, ...] | [[a1, ...], [a1, ...], ...] | .

--------
eager-attachment-at-bounary: Eager option attachment at repetition boundaries
--------

In the following example, the -z option will bind eagerly to the repeated
triplets of positionals.

    Grammar:                  cmds=(<a> <b> <c> [-z]){2,7}
    Example input:            A1 B1 C1 -z A2 B2 C2
    Returned data for cmds:   opts.cmds[1] = Namespace(a=A1, b=B1, c=C1, z=False)

That policy is consistent with greedy parsing elsewhere. Configuration for this
issue will have to be done via the API.

--------
grammar-syntax-named-unnamed: Grammar syntax: named and unnamed arguments
--------

Positionals must be named:

    frob <a> <b> [<c>]

Option arguments can be named or unnamed:

                                        # opts.mode:
    frob --mode {group} {name} {n}      # - Data object with attributes.
    frob --mode {} {} {}                # - Tuple.

--------
variants-needed: Variants: why they are needed
--------

Are variants needed give that the grammar syntax already has support for
alternatives?

Partial variants are a useful device to express some grammars more
conveniently.

Usage variants are a good mechanism for the user to help Optopus generate more
readable usage text and more relevant portions of it in response to errors.

Variants can provide a low-config mechanism for subcommand-style programs to
provide subcommand help text.

Variants have been a useful concept, and their names convenient handles, when
thinking about and planning this project. That utility might come in handy
later.

So one might think of the following related concepts, from most general
to most specific:

    Group           # Any grouping of grammar elements.
    Alternative     # A grouping where the end-user should choose one.
    Variant         # An alterantive that strongly affects usage text.

--------
destination-assignment: General destination assignment: needed after all
--------

Optopus does need generalized destination assignment. At a minimum, it needs
that feature not just for Opt, but also for partial variants. And once you go
that far, you might as well generalize it.

Consider examples like neck-diagram (nab is similar). With destination
assignment, the specific Opt destinations (cmd, snum, syms, etc) will be nested
underneath the 'commands' namespace (the outer destination assignment). The returned
data would have this structure:

    opts.commands : (
        Namespace(cmd = 'snum', snum = 6),
        Namespace(cmd = 'tuning', notes = ('E', 'A', ...)),
        Namespace(cmd = 'fret', syms = ('1', '3', '5')),
        ...
    )

Without the outer assignment, the returned data would be grouped by the Opt
destination names -- which badly jumbles everything up:

    opts = Namespace(
        cmd   : ['snum, 'tuning', 'fnum', 'fret', 'fret', ...]
        snum  : ['6']
        fnum  : ['5']
        notes : [[...]]
        syms  : [[...], [...], ]
    )

--------
grammar-syntax-complexity: Grammar syntax: is it too complex?
--------

To evaluate the question, I focused on the least intuitive aspect of the syntax
and compared it against the API-driven alternative:

Alternatives:

    - This is an easy call: syntax is intuitive and API usage for this
      situation is annoying.

    - This is a strong example of the superiority of text syntax for grammar
      configuration relative to API.

Quantifiers:

    - The ... is intuitive and practically a convention.

    - The {m,n} syntax directly mimics regex and is also quite intutive.

General destination assignment:

    - This feature is powerful: it allows grammar variation when
      a positional or parameter takes a specific value.

    - Configuring such matters via the API requires the user to understand how
      the library works a bit too closely.

Partials:

    - API usage would require the user make multiple configurations to mark a
      variant as partial and then insert it wherever needed.

    - The partial syntax isn't heavy; in fact, it's moderately intuitve and
      without it, the grammar syntax might even be a bit less immediately
      understandable.

Zones and anchoring:

    - I suspect the desire for zones and anchoring is moderately low but still
      more than nothing.

    - Also, configuring these parameters via the API is simple to understand
      and requires little code.

    - While the zone syntax not too obtrusive, and it is a mixture of intuitive
      (zone markers) and not very intuitive (anchor markers)

    - Infrequent use case, easy to handle via API: let's drop it from grammar syntax.

    - Another question: is the zone concept needed, or could Group do the same
      thing? I increasingly think so.

High precedence:

    - Setting this attribute is easy in the API.

    - Although the syntax is not heavy, it's also not fully intuitive.

    - The majority of use cases will get the built-in help behavior, and the
      library could interpret --help and --version options as high precedence
      by default.

    - Infrequent use case, easy via the API: let's drop it.

--------
optional-positional-placement: Optional positionals before required are not a problem
--------

One might be concerned about Grammars containing optional positionals before
required ones. For example:

    [<m>] <x> <y>

But this is not a problem is we just adhere consistently to greedy policy.
If the user wants positionals attached to <x> and <y> before <m>, they
can express the grammar differently.

--------
parse-known-args: Parse known arguments
--------

How argparse handles it:

    - Instead of returning a single Namespace it returns a tuple:

        (Namespace, List[unknown args])

    - It does still apply all validations to any supplied arguments.

I have found that approach mildly annoying:

    - It requires a change to the calling code to call a different
      method and to unpack the 2-tuple.

    - That makes it a bit less convenient to drive via typical configuration
      mechanisms.

I think it makes more sense for Optopus to treat parse-known-args as one of the
parsing modes that it supports:

    Parsing modes:

        Configured: these modes can be combined. They relax the rules to allow
        deviations:

            unknown-ok
            unconverted-ok
            invalid-ok

        No configuration: these modes are exclusive:

            Mode    | nparams
            -----------------
            flag    | 0
            key-val | 1
            greedy  | 0+

Optopus:

    - By default:

        - Continue to return a single Result object.

        - Put the unknown arguments in an attribute with an uncommon name, such
          as 'others' or 'unknowns'.

    - Let the user configure this:

        - Name of the unknowns attribute.

        - Whether to return (Result, List[unknowns]) tuple, like argparse.

--------
destination-scopes: Destination scopes
--------

By default, a destination used in multiple places within a grammar are assumed
to refer to the same underlying Opt.

    Example 1:

        <x> <x>

    Example 2:

        foo : <x> [-y]
        bar : -z -y <x> <x>

    Example 3:

        foo : <x> [-y]
        bar : -z -y [-x]

    Example 4:

        foo : <x> [-y]
        bar : -z -y <x>

It seems like the right default behavior, but it opens up some questions:

    (1) What if the grammar contains two or more fundamentally different Opt
    types for the same destination, as in Example 3?

    (2) What if the user wants different configuration for the same destination
    in different locations within the grammar? The nab script, for example,
    seems to demand this kind of flexibility: each nab command needs its Opts
    to be independently configurable.

Decision:

    - Within a variant, all Opt/Group dest values must be unique.

    - Opts having the same dest across different variatns are treated as the
      same underlying object, unless:

        - The spec requires them to have different configuration, as in
          Examples 2 and 3.

        - The user explicitly requests independence via the API.

            p.query('x').independent()

--------
zones-not-needed: Zones not needed
--------

In my planning I think the concept of Zones was not useful. A zone has no
purpose on its own; rather, it existed purely to support anchoring. And the
anchoring configuration was applied to Opts, not Zones. Just use Groups and
allow Opts to be anchored within them.

--------
help-distpatching: Help distpatching
--------

Optopus aims to support behavior like this:

    frob --help              # Print general help.
    frob configure --help    # Print help for the configure task.

How does the user configure this help dispatching. More generally, what about
supporting other help-printing scenarios that rely not on --help but on some
other options: for example, I've had programs where I want --examples to print
some usage examples for the end-user.

    - Simple use case: standard help feature for a command-line program.

        p = Parser(help = True|False)

    - Help hook: any time the library's help feature is triggered, call the
      user's function with some params and let them return something to tell
      the library which help section(s) to print, if any.

        p = Parser(help = CALLABLE)

    - That approach is flexible for the general case, but it does not speak to
      the most common type of complex use case (a program with subcommands,
      where the subcommands and help sections have a 1:1 correspondence). Some
      additional conveniences to support dispatching based on subcommands --
      or, more correctly, based on the value taken by a specific Opt.

        # For 1:1 correspondence between help sections and Opt values.
        o = Opt('task', help = 'sections')

        # For more flexibility, supply mapping from Opt value to section name.
        o = Opt('task', help = DICT)

--------
argparse-and-greed: argparse and greediness
--------

The argparse library does attach arguments greedily, but it makes no attempt
to backtrack. An example:

    Grammar:

        -z {}... <y> <y>

    Example input:

        -z A B C D E F

    Behavior:

        - Attach everything to -z.
        - Raise error because <y> not given.

--------
end-user-errors: End-user errors
--------

The problem:

    - Each Parser.parse(args) call will generate up to N failures, one per
      interpretation.

    - Ideally, we would report the error most aligned with end-user intent.

    - How do we select the error to report?

Initial ideas for mechanisms to select the most relevant error:

    - Error type, under the theory that some errors are more likely to
      convey intent about which alternative was (or was not) intended.

    - Percentage of input args matched, under regular parsing or
      perhaps forge-ahead parsing.

    - Percentage of available options present in the arguments, under the
      theory that the presence of options is one of the more telling indicators
      of intent. This metric is fairly easy to compute (a frequency distribution
      of options present).

Inferring intent from error types is tempting but not always so powerful:

    - Globally unknown options are an easy case: always select this error,
      because it's true under any interpretation.

    - One might think that an inapplicable option conveys that the current
      interpretation was not intended. But it's easy to create
      counter-examples: for example, a large N of arguments that work perfectly
      for the current interpretation, but the end-user inadvertently included
      an option for a different variant as the first argument (maybe when
      editing a prior command from shell history).

    - Invalid values might seem like an indication the current interpretation
      was intended, under the theory that the args were allocated to a slot but
      just failed in the details. But to know that with any confidence you need
      forge-ahead parsing.

The resolution is to consider how other parsers behave:

    - They always try to consume as much of the input as possible. This suggests
      that the first criterion for error-selection is S.ai.

    - Multiple interpretations can fail with the same S.ai. To resolve ties,
      consider how errors can occur (consuming an OPT, consuming a POS, or
      during final checks). For each of those cases, the error-reporting
      precedence is fairly clear-cut [listed below].

    - To resolve ties, report the error associated with the earliest
      alternative, based on the grammar.

Types of errors in precedence order, by failure source:

    - Trying to consume an OPT:

        - Globally unknown option.

        - Inapplicable option for current alternative (but known to grammar).

    - Trying to consume a POS:

        - Conversion/validation problems: params.

        - Conversion/validation problems: positionals.

        - Excess arguments.

    - Making final checks:

        - Insufficient ntimes: option.

        - Insufficient nparams.

        - Insufficient ntimes: positional.

        - Insufficient nargs.

--------
converters-validators: Converters and validators
--------

Function signatures:

    Function  | Arity | Signature
    -------------------------------------------------------
    Converter | 1     | STR            => OBJ/raise
    Validator | 3     | VAL, OPT, RES  => True/False/raise
    Dispatch  | 3     | VAL, OPT, RES  => None

--------
grammar-querying-api: Grammar querying API
--------

Grammary querying API

    - Because the Grammar can be a tree structure, the API needs good syntax to
      query for grammar elements, both for configuration needs (including the
      ability to perform bulk configurations) and for complex validations.

    - Possible approach:

        g.get(NAME, NAME, ...)          # Get one, dive-style.
        g.get(NAME, [NAME, ...], ...)   # Get multiple.

--------
validation-notes: Validation notes
--------

What to validate:

    - Only user-facing code: the entry points.

    - Let internal code blow up if given bad input.

Consider using a library:

    - valid8 is interesting but seems a bit over-engineered.

    - Its docs point to other tools that could have interesting ideas.

If not a library, consider implementing a simple validation module for the
project:

    - Some of the libraries I saw treated the process very formally, with a
      large API to learn.

    - A simpler approach seems better.

        validate(
            value,      # Value to check.
            convert,    # Callable: value => converted-value
            validate,   # Callable: converted-value => bool
            error,      # Error to raise.
        )

Where should validation logic reside?

    - Option 1: near the call site, so that you do not have to look elsewhere
      to understand the function.

        - Using decorator. Validation library writers seem attracted to this
          approach, but I don't see the appeal. It does not save any typing,
          and I find decorators with a lot of content to be awkward looking --
          aesthetically unappealing.

            @validate(
                x = (
                    int,
                    lambda x: x in range(1,11),
                    'x parameter must be interger 1 through 10: {val}',
                ),
                y = (...),
                z = (...),
            )
            def bar(x, y, z):
                ...

        - Or just using an ordinary function:

            def bar(x, y, z):
                validate(
                    x,
                    int,
                    lambda x: x in range(1,11),
                    'x parameter must be interger 1 through 10: {val}',
                )
                validate(y, ...)
                validate(z, ...)
                ...

    - Option 2: put validation logic a separate module, consolidating such
      details in one location. Let readers focus on the happy-path substance of
      the function, not the grubby validation logic, exception raising, etc.
      That code is mostly formulaic anyway -- stick it in the footnotes.

            # Main code.

            @validate
            def bar(x, y, z):
                ...

            # Validation module:

            register_validators(
                bar = (
                    x,
                    int,
                    lambda x: x in range(1,11),
                    'x parameter must be interger 1 through 10: {val}',
                ),
                ...
            )

        Under this approach, you want the validators to be composable, with the
        ability to define a bigger validator using smaller validators.
        And such compositions may need some helpers:

            validate_all()

--------
strategy-reassessment: Reassess the strategy
--------

After further reflection and looking again at the various job-client* example
scripts, I realize I underestimated the power of the text-based configuration
syntax.

    - It's true that I did find writing the literal help text tedious. I also
      dislike the idea that it will lack dynamic formatting behavior.

    - However, the API based configuration is very ineffecient and repetitive
      compared to the brevity, clarity, and intutiveness of the text approach.

    - Perhaps the right path, again, is to used text-driven configuration, but
      as syntax, not literal help text.

Consider which parts of the ultimate help text must be typed directly by the
programmer:

    - Option or argument names.
    - Help text for each option/argument.
    - Metavars.
    - Aliases.
    - Section names.
    - Choice values (if simple strings).

The simplest, clearest way to write that material is as a block of options
text. Lines likes these cover all of those bases:

    General::
    --job-id -j ID    : The job id.
    --od-user -u USER : Open Directory user who submitted the job.

The only other configurations are (a) syntax for complex grammars, and (b)
stuff well handled by the API (defaults, types, conversion, validation,
dispatch, sometimes choices, etc).

And this text-centric approach is flexible in allowing a variety of
usage patterns:

    - It can be treated as literal options text, for those who prefer that
      approach. Essentialy, Optopus will support a Docopt mode.

    - But treating it as configuration syntax will be easier for many who (1)
      don't want to have to lay everything out precisely and (2) especially
      don't want to have to define a usage grammar even for programs with
      standard command-line needs. If the API approach is ineffecient
      generally, the literal-text approach is ineffecient in requiring a usage
      grammar every time (as docopt does).

The write-up will need to be reframed to emphasize the debt to the text-based
argument parsers and to criticize the API approach for being so inefficient. In
the writeup place greater emphasis on some practical examples illustrating the
superiority of the text-based approach over argparse.

--------
grammar-syntax-revisited: Grammar syntax revisited
--------

Enhance spec syntax increase its power, reducing user hassle:

    - Program name.
    - Options text, optionally with section titles.
    - Opt symbols.
    - Regular text.

Simplify and unify the syntax:

    - Ensure that Optopus supports the full spectrum of usages, ranging from
      quick-and-dirty to complex.

    - Prioritize ease of use for the simplest cases.

        - Program name optional.
        - Variant names optional.
        - Section headings optional.

    - Minimize baroque syntax elements:

        - Reduce special punctuation when possible.
        - Meaningful whitespace is more intuitive that odd punctuation.
        - Make surviving punctuation as unified/congruous as possible.

Representing variable end-user inputs:

    - There are four common styles for representing variable end-user input,
      along with some differences in details for specific implementations,
      especially as it relates to choices:

        Style     | Parameters  | Positionals | Choices | Examples
        ----------------------------------------------------------------------------
        Angle     | <>          | <>          | {}      | git, picocli
        Sensitive | UPPER       | lower       | {}      | argparse, many Python/Ruby
        Lower     | lower       | lower       | () []   | POSIX, many Unix utilities
        Upper     | UPPER       | UPPER       | ?       | rsync
        ----------------------------------------------------------------------------
        Docopt    | <> or UPPER | <>          | () []   | .
        Optopus   | <>          | <>          | <>      | .

        - Parentheses or brackets are used where needed to resolve ambiguity
          between parameters and arguments.

        - Unclear how docopt handles choices, but I think it uses
          parens/brackets.

        - Not sure why Git uses braces for choices: angle brackets seem to work
          fine and are consistent.

    - We can reject the lower and upper styles:

        - They work poorly for positional variants and parameter variants.

        - Usage text is ambiguous: we cannot distinguish merge/delete
          (positional variants) from path (variable input).

            frob [-f] merge [-x] [-y] path
            frob [-f] delete [-z] path

    - The sensitive style is not so easily dismissed:

        - It handles most situations:

            frob [-f] merge [-x] [-y] PATH
            frob [-f] delete [-z] PATH

        - And the Python/Ruby community is accustomed to it (from argparse and
          its predecessor, optparse).

        - It does fail if the variant values need to be uppercase. Some type of
          quoting or other syntactic workaround would be needed:

            frob [-f] `MERGE` [-x] [-y] PATH
            frob [-f] `DELETE` [-z] PATH

    - The angle style is the most robust:

        - In order to produce robust usage text for variants, literal inputs
          need top precedence.

        - This demands that variable inputs be enclosed, making case-based
          solutions either flawed or insufficiently robust.

        - Optopus was drifting toward {param} and <pos> as the enclosures:

            - That would also be an odd combo. The only precedent is docopt,
              which supports it as an alternative syntax.

            - In addition, braces have a semi-conventional role for choices in
              tools like argparse.

    - Verdict: default to angle style.

        - The clarity of the approach seems to more than counterbalance the
          small increment of extra typing: all variable inputs are enclosed in
          the same way (positionals, parameters, and thus choices).

        - The approach has strong precedent, especially from Git.

        - When needed, use parentheses or brackets to disambiguate parameters
          and positionals. That will be rare because: (1) most use cases do not
          require an explicit grammar; (2) most options are optional and will
          be bracketed already; and (3) most ambiguitities can be resolved by
          adjust option ordering in the grammar.

        - If needed later, support other styles for usage text and grammar
          syntax (especially sensitive). Note that sensitive style in usage
          text is partially supported via the SYM! notation.

Punctuation markers:

    - Summary of plan:

        Situation       | Marker       | When required
        -------------------------------------------------
        Grammar section | Double colon | If multi-variant
        Other sections  | Double colon | Always
        Opt help        | Colon        | If help text
        Variant         | Colon        | If named

    - Sections:

        - The grammar section:

            - Must appear first in the spec. If user wants a different section
              ordering: define the sections in the spec; use API to move
              sections as needed.

            - No regular text.

            - Default title is `Usage`, configurable only via API.

        - The grammar section, regardless of form, can be followed by zero or
          more other sections that:

            - Must use marker.
            - Can omit a title.
            - Can define opt-help lines.
            - Can include regular text.

            - If a line parses as opt-help, it will be interpreted that way
              (unless quoting is used).

        - What if the user does not want a trailing colon on section titles?

            - Let them adjust via the API.

    - opt-help:

        - Supported Opt grammar subset:

            sym
            dest
            nargs
            nparams
            ntimes
            choices
            aliases
            text

        - Note that opt-help uses a grammar subset, not an alternative grammar:

            - This means, for example, that options are not assumed
              to be optional: square brackets required if intended.

        - Note that opt-help lines can be confused with unnamed variants. The
          issue is fundamental, not really addressable via extended peeks or
          other fancy parsing. For example, does this spec define 3 variants or
          3 bare-bones opt-help lines?

            pgrep
            <rgx>
            --ignore-case -i
            --invert-match -v

        - The most common use case is to derive grammar from 1+ opt-help
          sections. It works well for many standard grammar needs, and opt-help
          is more featureful than variant (because it supports aliases and
          text). So the no-variant use case should have the least hassle.

Dest, sym, and values:

    - Examples without choices:

        Example                 | Usage text            | Dest
        ------------------------------------------------------------------
        <paths>...              | <paths>...            | paths
        <path.paths>...         | <path>...             | paths
        <PATH!paths>...         | PATH...               | paths
        ------------------------------------------------------------------
        --strategy <s>          | --strategy <s>        | strategy
        --elems <e> <e> [<e>]   | --elems <e> <e> [<e>] | elems
        --point <row.x> <COL!y> | --point <row> COL     | point.x, point.y
        --point <.x> <.y>       | --point <p> <p>       | point.x, point.y
        --point <> <>           | --point <p> <p>       | point
        ------------------------------------------------------------------

    - Examples involving choices and positional/parameter variants:

        Example               || Usage text        || Dest
        --------------------------------------------------------------------
        <mode=fast|slow>      || <fast|slow>       || mode
        <mode=fast>           || fast              || mode
        <MODE.mode=fast|slow> || mode              || mode
        <MODE!mode=fast|slow> || MODE              || mode

--------
spec-as-format-string: Spec as a format string not needed
--------

Initially I thought it would be useful to allow the spec to function as a
format string.

But if the format() call occurs early (before spec parsing), there is no
purpose served: the user could just call format() to create the spec in the
first place.

There might be a use case for calling format() after parsing has derived
grammar and opt-help metadata.

    - Presumably the purpose would be to insert material into help text that is
      more under the domain of Optopus than the user.

    - Another possible use case is to call format() after end-user
      arguments are parsed -- eg, in response to error.

    - Defer this until a use case is known.

