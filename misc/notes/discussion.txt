--------
toc: Table of contents
--------

    toc                          | Table of contents
    api-vs-text                  | API-driven vs text-driven
    other-lib-weaknesses         | Addressing weaknesses common in other libraries
    other-goals                  | Other goals
    standard-cli-grammar         | Standard command-line grammar
    cli-grammar-vs-regex         | Command-line grammar vs. regex
    subparsers-not-needed        | Optopuss does not need the subparser concept
    opt-action-not-needed        | Optopuss does not need the 'action' concept
    explicit-option-param-syntax | Why explicit syntax for option parameters is needed
    high-precendence-options     | High precedence options
    help-text-formatting         | Help text formatting
    alternative-parsing-algo     | Alternative parsing algorithm won't work after all
    abmiguous-grammars           | Ambiguous grammars are not an issue
    basic-arg-parsing-algo       | Parsing algorithm
    parsed-data-structure        | Parsed data structuring: nargs, nparams, ntimes
    eager-attachment-at-bounary  | Eager option attachment at repetition boundaries
    grammar-syntax-named-unnamed | Grammar syntax: named and unnamed arguments
    variants-needed              | Variants: why they are needed
    destination-assignment       | General destination assignment: needed after all
    grammar-syntax-complexity    | Grammar syntax: is it too complex?

--------
api-vs-text: API-driven vs text-driven
--------

Two fundamental configuration strategies for argument parsers:

    - API-driven:

        - User configures a parser via the programmatic API.
        - The parser generates the help text.
        - Typically allows user to override with literal help text, if desired.
        - Examples: argparse and many others.

    - Text-driven:

        - User writes literal usage and options text.
        - Library derives the parser from that text.
        - This approach is much less common.
        - Examples: docopt.

The optopuss library combines the best of both approaches:

    - API-driven.

        - Tends to require less typing.

        - Generated usage text is mostly fine, especially for simpler projects.

        - Most developers probably prefer an API-driven approach over
          hand-formatting help text themselves.

        - API-generated help text will follow the conventions for documenting
          command-line programs -- conventions that few developers have studied
          in depth and would rather not worry about.

    - Text-driven for grammar and naming:

        - Even though my experiments configuring argument parsers of varyig
          complexity via usage text convinced me of the benefits of an
          API-driven approach, text-driven option parsers have notable
          advantages. Those advantages are focused on command-line grammar and
          the associated naming for parsed data returned to the caller.

        - The text-driven approach emphasizes the idea of usage variants, a
          technique that can greatly enhance usage-text readability --
          especially for complex programs but also for small ones.

                git diff [<commit>] [--] [<path>...]
                git diff --cached [<commit>] [--] [<path>...]
                git diff <commit> <commit> [--] [<path>...]

                frob [--debug] [--foo <f>] <path>...
                frob --help
                frob --version

        - Usage variants open up a range of possibilities in the kinds of
          command-line grammars that can be supported. API-driven parsers
          struggle with command-lines that need any grammar falling beyond the
          most typical cases. On stackoverflow and bugs.python.org, for
          example, one can find many command-line use cases (some of them quite
          simple) that are not supported easily by argparse but that are
          straightforward in docopt.

        - Finally, usage syntax is both efficient and intuitive. When internet
          users discuss command-line grammar scenarios, they invariably use a
          usage syntax to specify the desired grammar. In my own research, I
          experimented with defining the needed grammars via an API, but I
          consistently found the text-based approach simpler to express and
          read.

Configuration via usage syntax is focused on grammar:

    - Optopuss keeps that syntax fairly clean, readable, and intutive by
      focusing it solely on the grammar and naming -- the area where it excels.
      Other details, if any, are handled via the API.

    - The syntax is also intuitive because it relies heavily on common
      conventions for documenting command-line programs.

    - The syntax will look roughly like familiar usage text, plus a small
      number of additional syntax elements focused on supporting flexible
      command-line grammar.

          - Usage variants. Discussed above.

          - Partial variants, which use the variant concept to define a named
            group of options and/or arguments that can then be inserted into
            one or more usage variants -- avoiding repetition in the definition
            of complex grammars.

          - Named destinations for literal-positionals, variants, and
            any other group of elements in the grammar.

    - The syntax opens up a wide range of possibilities for complex programs or
      unusual grammars

    - But it also helps at the micro scale, simplifying the configuration of
      individual options.

--------
other-lib-weaknesses: Addressing weaknesses common in other libraries
--------

Providing users with simple ways to handle command-line grammars and usage
variants (just noted).

Supporting everything from quick-and-dirty scripts to complex, highly
customized command-line programs, with other variants in between.

    - At once extreme, optopuss allows you to parse any default-behavior
      command line, with zero configuration. Just import and go. This parser
      won't enforce any rules, but it will tell you what the user entered --
      which is good enough for many types of quick-and-dirty scripts, debugging
      sessions, experiments, and even early prototypes.

            import optopuss
            opts = optopuss.parse_args()

    - At the other extreme, you could build the next Git or a variety of
      programs with idiosyncratic grammars, heavily customized help text, and
      many other features.

    - Sitting between the two extremes are numerous conveniences and sensible
      defaults to make option parsing easy, no matter what level of control
      your application needs.

Allowing users to control the generated help text in a fine-grained manner.

    - Program complexity increases the need to organize and fine-tune help
      text, but not necessarily to write and layout the whole thing.

    - Optopuss provides many mechanisms for that fine tuning:

        - Simple top-level configurations to control basic layout,
          capitalization, punctuation, etc.

        - Support for common styles: command-line vs man-page.

        - Ability to group options into sections.

        - Ability to supply hand-crafted sections whenever needed and to locate
          those sections with precision in the output.

        - Ability to control nearly all parameters driving the help text
          contruction process via configuration and, where necessary, through
          the programmatic hooks. There should be no need to subclass optopuss
          or delve into the parser's innards.

Allowing users to enhance usage-text readability by being able to refer to
groups of options and to omit either short or long options.

    - API-generated usage text tends to be poor not only because it lacks usage
      variants but also because the generated text exhaustively lists all
      options in all of their permutations (short and long).

    - Especially as the number of options grows, readability can be improved
      greatly by referring to sets of options by symbolic names rather than by
      enumerating every possibility.

    - Similarly, readability can be enhanced by focusing the usage text on just
      the long-options (or just the short-options) and then providing a mapping
      between short and long options latter in the help text.

Allowing users to define their arguments and options in ways that encourage
modularity.

    - In optopuss a user defines options and arguments as atomic units,
      separate from the issues of command-line grammar, usage variants, and
      options help text.

    - Each of those atomic units can be assigned to one or more groups of
      related options.

    - Then those options or option-groups can be leveraged when defining the
      command-line grammar, when expressing the generated usage text, and when
      organizing the options text into sections.

Providing users with full access to the parser configuration, both via the API
and in the form of standard, serializable data structures.

Providing users more conventient mechanisms to reduce repetition in
the configuration of the parser.

--------
other-goals: Other goals
--------

Prioritize the simple use cases. Yes, add features and customization
capability. But do that without sacrificing super super usage patterns.

Should handle both positional arguments and options.

Usage should be intuitive and declarative, especially for the simplest and most
common use cases. It should not bizarre syntax or on user-created complex data
structures.

The parser's configuration should be expressible as a data structure -- and
creatable from one. This is important for testing, debugging, easy integration
with config files, and using other libraries for data validation.

For complex programs or special needs, users should have full control over
documentation. This includes both usage/help text and the styling of error
messages.

Easy system for validators to be combined flexibly.

Should be applicable to validating subroutine arguments, both positional and
key-value.

Should support subcommand applications, like svn or git.

Should easily support different help types: (a) brief usage/synopsis, (b) full
help or man-page, and (c) extras or examples.

Include ability to merge options from several sources: ENV variables, config
files, command-line options. Note that the purpose of the configuration sources
(ENV vars and config files) is to set the default values used by the
command-line option parser. When defaults are supplied, it should also cause a
required option to become non-required (in other words, whenever default is set
for an option, it causes required to become False.

Make it easy to test the option parser.

Error handling should be under the user's control, if they want it. This is a
serious flaw in some parsers (eg argparse). The library should support both
"automatic" mode (where the parser will eagerly print help or error message and
then exit) or non-automatic mode (where the parser will simply return an object
containing all information and allow the user to decide what to do.

Should have a design that is friendly to customization. Allow users to
customize by writing simple functions or hooks rather than having to subclass.
Consider using the pluggy library so that users can implement simple function
hooks.

Start simple: begin with core behaviors; don't support more flexibility until a
basic working system is in place.

Where possible, rely on convention over configuration: sensible defaults to
allow the most common path to be followed with minimal setup.

Provide good support for --version. Show the application's name and version
number.

Provide helper functions for warn(), exit().

Support various configuration styles: per option configuration (argparse and
many other libraries do this); and thematic or bulk (make one type of setting
on multiple options at once).

Allow the user to have hidden options (eg for developers only).

Support file and dir types as arguments, with checks for existence or non-existence.

For file path arguments, support the ability to treat `-` as stdin or stdout.

Support an easy way to get bash completion.

Support @somefile.txt: user supplies command-line args via a file.

Support parse_known_args().

Support abbreviated option names when there is no ambiguity.

Support some no-configuration argument parsing strategies: default (options are
flags), key-val (options take single args by default), greedy (options consume
as many params as possible).

Support conversion/validation.

Support dispatch mechanisms.

The parser's configuration is likely to be organized as a fairly deep
tree behind the scenes. But make it easy for the user to query that
tree to obtain nodes of interest for configuration and other purposes.
Primarily this means quickly getting Opt instances, but there could
be other types of interest as well.

Let users control the important aspects of the help text: section ordering;
section titles; layout style (eg, compact 2-column or man-page); capitalization
rules; widths; conventions for showing default values; etc.

--------
standard-cli-grammar: Standard command-line grammar
--------

Typical rules of command-line grammar, as commonly understood in Unix tradition:

    - Options start with a prefix:

        --long
        -s

    - Options can take zero or more ordered parameters.

    - Positional arguments are ordered among each other:

        P1 P2 P3 ...

    - Options can be ordered in any way:

        --x4 --x1 --x3 --x2 ...

    - Options can be freely interspersed among the ordered positional arguments.

        --x3 P1 --x1 --x4 P2 --x2 P3 ...

    - Short options can be bundled:

        -x -y -z
        -xyz

--------
cli-grammar-vs-regex: Command-line grammar vs. regex
--------

Although Optopus usage syntax borrows many concepts from regular expressions,
command-line grammar parsing is not readily amenable to handling via regex
parsing approaches.

Positionals are ordered among themselves, but options can appear in any order
(ignoring boundaries and anchors). That flexibility makes it not very intuitive
to convert a command-line grammar into a manageable regular expression. At
every stage, any of the options are possible. But then once an option appears,
it cannot appear again (ignoring repeatables). That means command-line parsing
is context-sensitive.

--------
subparsers-not-needed: Optopuss does not need the subparser concept
--------

The subparser concept is much less powerful and flexible than the key concept
of a command-line grammar, along with the related ideas of usage variants and
flexible destination assignment. It's also less intuitive.

The universe of command-line programs could be broken down into a sizable
majority and three small minorities:

    - A sizable majority that needs neither subparsers nor a complex grammar.

    - A small minority that are forced by the limitations of current argument
      parsing libraries to resort to subparsers even though the concept does
      not align very well with their needs.

    - A small minority that align conceptually with the subparser concept. But
      command-line grammar supports this use case even better.

    - A small minority that must hack their way around the current limitations.

--------
opt-action-not-needed: Optopuss does not need the 'action' concept
--------

Arguments can be configured in argparse with an 'action' parameter. The
parameter is a bit overloaded and misleading. It does control some actions (eg,
showing help text), but mostly it is used as a sometimes misnamed device for option type
and destination assignment.

    Action       | Option type       | Example         | Stored      | Notes
    ----------------------------------------------------------------------------------
    store_true   | 1 flag            | --frob          | True        | True == 1
    store_false  | 1 flag            | --frob          | False       | Can override True default
    count        | 1+ flags          | -v -v           | N           | .
    store        | Single            | --foo F         | F           | .
    append       | Repeatable single | -x A -x B       | [A, B]      | Overwrite on repeat
    extend       | Repeatable multi  | -x A B -x C D E | [A B C D E] | .
    help         | High precedence   | .               |             | .
    version      | "    "            | .               | .           | .
    ----------------------------------------------------------------------------------
    store_const  | 1 flag            | --frob          | X           | Not necessary
    append_const | 1+ flag           | --frob --frob   | [X x]       | Not necessary

--------
explicit-option-param-syntax: Why explicit syntax for option parameters is needed
--------

Without an explicit syntax to mark option parameters, various grammar
ambiguities are possible. For example:

    - Should we interpret --type as a flag or an option taking a
      literal parameter?

            frob --type (file|dir|link)

    - How many parameters does --group take: 0, 1, or 2?

            frob --group (a|b|c|d) (x|y)

    - Special syntax for literal choices (for examples, the conventionally used
      braces) helps only in the case when nparams equals 1.

The relatively low cost way to resolve such issues to an explicit syntax for
any command line arguments that vary (the non-literals). Everything else
is a literal or unambiguously part of the grammar syntax.

    Positionals:

        <x> <y>

    Parameters:

        --person {name} {age}            # Named.
        --sort {quick|bubble|merge}      # Literal because of choices.
        --sort {'quick'}                 # Literal because of quotes.

    Literals:

        task=get                         # Named destination.
        /                                # Unnamed literal (eg separator)

--------
high-precendence-options: High precedence options
--------

Most options control the primary behaviors of a program. But some are
special, most notably those related to user help:

    --help
    --version
    --examples
    --demo

Argument parsing libraries often provide an convenient mechanism for --help and
sometimes --version, but rarely anything else. In addition, they tend to
provide such features in a way that is slightly misleading (at least in a
strict sense) and definitely not as convenient for users as it could be.

Consider a simple subcommand-style program. Assume that both <id> and the
parameter for -n should be integers and that the program has both general help
text and subcommand help text.

    demo [--help] [-n {}] (print|delete) <id>

At least by default, if the end-user supplies the --help option, an argument
parser should (1) print help text and exit, (2) select the help text that is
relevant given the other command-line arguments, and (3) ignore errors in the
other command-line arguments. Some examples of desired behavior:

    demo --help                # General help.
    demo --help delete         # Delete help.
    demo --help -n HI delete   # Same, in spite of invalid -n parameter.

Most argument parsers fail on #3 (they gripe instead of helping) and they do
not easily support #2.

Optopuss addresses those problems with two mechanisms: high-precendence options
and flexible dispatching. If an option is configured to be high-precendence,
its presence among the command-line arguments will trigger whatever action it
has been configured to perform, and that dispatching configuration will take
precendence over error reporting. When high-precendence options are used, the
parser performs a best-effort parsing to collect as much contextual information
as it can before calling the code responsible taking action.

There are limits, of course. Some types of bad input can reduce the accuracy of
that best-effort parse. In this example, -Q in an unknown option and is treated
by default as a flag taking no parameters, which then means that HI is is
interpretted an invalid subcommand.

    demo --help -Q HI delete   # General help rather than delete help.

--------
help-text-formatting: Help text formatting
--------

Text wrapping:

    - Respect terminal widths, if known and within boundaries:

        min_width = 40
        max_width = 100

    - Allow users to adjust those parameters.

    - User-supplied text:

        - Break into paragraphs (but preserve info about N of blank lines
          between paragraphs).

        - Rewrap to the desired width (probably using textwrap module).

        - Leave indented paragraphs as-is.

        - Provide an easy syntax for users to suppress line wrapping
          within the text (eg something borrowed from markdown)

--------
alternative-parsing-algo: Alternative parsing algorithm won't work after all
--------

The algorithm:

    - When parse() is called, there will be N command line arguments.
      Command-line use cases never have large N.

    - Using the parser configuration, assemble data on the aspects of the
      grammar that are not static. The most common non-static configurations:
      varying nargs, nparams, or ntimes; variants; and alternatives.

    - For grammar elements that have no inherent boundaries (eg, an option
      taking 1+ params), interpret them in as bounded by using N as the upper
      limit.

    - Use all of that information to generate all static grammars that satisfy
      the actual grammar.

    - Check each static grammar against the command line arguments.

    - A successful parse finds exactly one successful static grammar.

What causes a grammar to generate multiple possibilities?

    .              | Where expressed | Note
    -----------------------------------------------------
    Varying nargs  | Opt             | .
    Varying ntimes | Opt or Phrase   | Includes required.
    Aliases        | Opt             | .
    Alternatives   | Phrase          | Includes variants.

Benefits of the algorithm:

    - This code seems easy to write:

        - The generation of static grammars seems like a manageable
          situation involving itertools.

        - Parsing a static grammar very simple: no backtracking required.

    - It provides a run-time guard for users against ambiguous grammars.

Two concerns and one deal breaker:

    - The approach seems non-standard. A classic PEG algorithm seems to suit
      the situation. And that code might not be any harder to write -- perhaps
      just a bit less familiar. Why reinvent the wheel? Make sure there's a
      good reason.

    - Modern operating systems and shells have very large limits on the max
      size of command lines and N of arguments. Why build a good argument
      parsing tool that would fail at moderate values for N -- especially
      when a linear algorithm is known?

    - There won't necessarily be only one successful parse of the static
      grammars, as noted in the discussion of ambiguous grammars. By using a
      greedy assignment policy the parser can ignore that matter. But regular
      expressions have a greedy concept precisely because without it there can
      be more than one successful parse of an input.

--------
abmiguous-grammars: Ambiguous grammars are not an issue
--------

From a strictly grammatical perspective, only one positional can have a
non-static nargs or ntimes, because there isn't exactly one valid way to attach
the values to the destination attributes. A similar problem occurs when an
option has non-static nparams and a positional has non-static nargs.
Two examples:

    <xray>...    <y>...
    --xray {}... <y>...

But that's not a problem, because Optopuss can do what regular expression
engines do: greedy assignment by default, non-greed by configuration.

--------
basic-arg-parsing-algo: Parsing algorithm
--------

Algorithm sketch: parsing one argument:

    - If option:

        - If it can bind to only one leaf in the Phrase tree, do so.

        - If there are alternatives leaves, collect them and prepare for
          possible backtracking. We will try each leaf in order.

    - Non-option:

        - Can the current option take args?

            - No: do not bind.
            - Yes, static: just bind.
            - Yes, variable: bind with possible backtracking.

        - Otherwise, we will bind to current positional Opt.

            - Static: just bind.
            - Variable: bind with possible backtracking.

--------
parsed-data-structure: Parsed data structuring: nargs, nparams, ntimes
--------

The meaning of nparams, nargs, and ntimes:

    nparams : N of params (for options)
    nargs   : N args (for positionals and theoretically literals)
    ntimes  : Governs only optionality and repetition.

    Options:                    #  nparams  ntimes

        -y                      #  0        (1,1)
        [-y]                    #  0        (0,1)
        [-y {} {}]              #  2        (0,1)

    Positionals:                #  nargs    ntimes

        <x>                     #  1        (1,1)
        [<x>]                   #  1        (0,1)
        (<x> <x> <x>){0,2}      #  3        (0,2)

    Literals:                   #  nargs    ntimes

        (veg|meat)              #  .        (1,1)
        [veg|meat]{0,3}         #  .        (0,3)
        digits=(1|2|3|4)...     #  .        (1,None)
        ((x|y) (x|y)){1,3}      #  2        (1,3)

Although literals probably won't need nargs in the real world (and could be
handled by nested ntimes configurations), it might be just as simple from an
implementation perspective to allow nargs for literals. One might be tempted to
think a similar not-strictly-needed argument could be made for positionals: the
last <x> example could be done with nested ntimes. But that would make the
grammar syntax less readable and less conventional.

Internally, all data assigned to destinations will be stored in a fully
explicit manner. Assume a list of lists, where nargs/nparams determines the
length of the inner lists and ntimes determines the length of the outer.

    self._values = [
          [a1, a2, ...],  # First time.
          ...             # Etc.
    ]

But attribute values returned to users will be as flat as possible, based on
nargs/nparams and ntimes (unless user requests non-flattened data).

    nargs/nparams | ntimes 0 or 1 | ntimes 2+ flattened                 | ntimes 2+ non-flattened
    ---------------------------------------------------------------------------------------------
    0             | bool          | [bool, bool, ...]                   | [[bool], [bool], ...]
    1             | a1            | [a1, a2, ...]                       | [[a1], [a2], ...]
    2+            | [a1, a2, ...] | [[a1, a2, ...], [a1, a2, ...], ...] | .

--------
eager-attachment-at-bounary: Eager option attachment at repetition boundaries
--------

In the following example, the -z option will bind eagerly to the repeated
triplets of positionals.

    Grammar:                  cmds=(<a> <b> <c> [-z]){2,7}
    Example input:            A1 B1 C1 -z A2 B2 C2
    Returned data for cmds:   opts.cmds[1] = Namespace(a=A1, b=B1, c=C1, z=False)

That policy is consistent with greedy parsing elsewhere. Configuration for this
issue will have to be done via the API.

--------
grammar-syntax-named-unnamed: Grammar syntax: named and unnamed arguments
--------

Positionals must be named:

    frob <a> <b> [<c>]

Option arguments can be named or unnamed:

                                        # opts.mode:
    frob --mode {group} {name} {n}      # - Data object with attributes.
    frob --mode {} {} {}                # - Tuple.

Literals can be named or not:

    frob action=div <a> / <b>           # Named (action=div), unnamed (slash).

    Unnamed literals won't be in the returned data for now. But support could
    be added later (data-wise it's like a flag with ntimes).

--------
variants-needed: Variants: why they are needed
--------

Are variants needed give that the grammar syntax already has support for
alternatives?

Partial variants are a useful device to express some grammars more
conveniently. 

Usage variants are a good mechanism for the user to help Optopuss generate more
readable usage text and more relevant portions of it in response to errors.

Variants can provide a low-config mechanism for subcommand-style programs to
provide subcommand help text.

Variants have been a useful concept, and their names convenient handles, when
thinking about and planning this project. That utility might come in handy
later.

--------
destination-assignment: General destination assignment: needed after all
--------

Optopuss does need generalized destination assignment. At a minimum, it needs
that feature not just for Opt, but also for partial variants. And once you go
that far, you might as well generalize it.

Consider examples like neck-diagram (nab is similar). With destination
assignment, the specific Opt destinations (cmd, snum, syms, etc) will be nested
underneath the 'commands' namespace (the outer destination assignment). The returned
data would have this structure:

    opts.commands : (
        Namespace(cmd = 'snum', snum = 6),
        Namespace(cmd = 'tuning', notes = ('E', 'A', ...)),
        Namespace(cmd = 'fret', syms = ('1', '3', '5')),
        ...
    )

Without the outer assignment, the returned data would be grouped by the Opt
destination names -- which badly jumbles everything up:

    opts = Namespace(
        cmd   : ['snum, 'tuning', 'fnum', 'fret', 'fret', ...]
        snum  : ['6']
        fnum  : ['5']
        notes : [[...]]
        syms  : [[...], [...], ]
    )

--------
grammar-syntax-complexity: Grammar syntax: is it too complex?
--------

To evaluate the question, I focused on the least intuitive aspect of the syntax
and compared it against the API-driven alternative:

Alternatives:

    - This is an easy call: syntax is intuitive and API usage for this
      situation is annoying.

    - This is a strong example of the superiority of text syntax for grammar
      configuration relative to API.

Quantifiers:

    - The ... is intuitive and practically a convention.

    - The {m,n} syntax directly mimics regex and is also quite intutive.

Destination assignment for literals:

    - To configure this via the API requires the user to understand how
      the library works a bit too closely.

    - More fundamentally, when a grammar uses literal alternatives, some type
      of name is required (which attribute name would Optopuss use?).

    - And there are other reasons for generalized destination assignment, so
      doing it for literals makes sense.

Partials:

    - API usage would require the user make multiple configurations to mark a
      variant as partial and then insert it wherever needed.

    - The partial syntax isn't heavy; in fact, it's moderately intuitve and
      without it, the grammar syntax might even be a bit less immediately
      understandable.

Zones and anchoring:

    - I suspect the desire for zones and anchoring is moderately low but still
      more than nothing.

    - Also, configuring these parameters via the API is simple to understand
      and requires little code.

    - While the zone syntax not too obtrusive, and it is a mixture of intutive
      (zone markers) and not very intuitive (anchor markers)

    - Infrequent use case, easy to handle via API: let's drop it.

High precedence:

    - Setting this attribute is easy in the API.

    - Although the syntax is not heavy, it's also not fully intuitive.

    - The majority of use cases will get the built-in help behavior, and the
      library could interpret --help and --version options as high precedence
      by default.

    - Infrequent use case, easy via the API: let's drop it.

