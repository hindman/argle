--------
grammar-syntax: Grammar syntax
--------

Overall structure:

    foo` : PARTIAL_DEFINITION
    bar  : VARIANT_DEFINITION

    Defintions can span multiple lines. Leading colon is required.

        foo` : Blah blah
             : blah blah
             : blah blah
        bar  : Blah

Variant definition syntax:

    Variants:

        foo`             Insert the foo partial into the current partial or variant.

    Grouping and alternatives:

        []               Grouping, optional.
        ()               Grouping.
        foo=[]           Named grouping, optional.
        foo=()           Named grouping.
        |                Alternatives.

    Quantifiers:

        ...              1 or more
        +                1 or more
        *                0 or more
        ?                0 or 1
        {m,n}            Repetition: m through n, inclusive.
        ?                Non-greedy for preceding quantifier.

    Positional arguments:

        <xy>             Positional.
        <xy=a|b>         Positional choices.
        <xy=foo>         Positional variant.

    Options:

        -x               Short.
        --xy             Long.

    Option parameters:

        Unnamed          Named
        --------------------------------------------------
        -p {}            -p {x}         Parameter.
        -p _             .              Parameter.
        -p {=a|b}        -p {x=a|b}     Parameter choices.
        -p {=foo}        -p {x=foo}     Parameter variant.

    Literals:

        'hello world'    Literal: can be used as positional, positional choice,
                         positonal variant, parameter choice, or parameter variant.

    Convenience syntax when configuring a single Opt:

        Positionals      Options
        --------------------------------------------------------
        x x [x]          -f _ [_]       Brackets/braces unneeded
        x=a|b|c          -f a|b         Choices.
        x=a              -f x=a         Variant.

    Whitespace rules:

        - Whitespace required:

            - Quoted literal containing whitespace (no user want this).

            - If a variant ends with an option, whitespace is needed before the
              next variant name (otherwise the names bleed together).

            - To disambiguate names in the convenience syntax for single Opts.

        - Tight-binding required among syntax elements:

            - Option prefix with name.

            - Partial name with back-quote (this could be optional, but
              there is no benefit).

--------
parsing-grammar-syntax: Parsing the grammar syntax
--------

Phase 1: input normalization:

    - Accept text and/or lines of text.
    - Join into a block of text.

Phase 2: lexing:

    - Remember that the lexer analyzes character by character to emit
      the meaningful atomic units of the language.

    - It does not engage in validation logic to assess whether the arrangement
      of those units is syntactically valid.

    - Nor does it try to assemble those character-based atoms into fully
      meaningful entitities, other than in cases where they must be assemble to
      avoid ambiguitity with similar tokens.

    - Regex snippets to build the token regexes:

        Spippets | Pattern
        ------------------------------------------
        letter   | [A-Za-z]
        nm       | letter (letter | \d)*
        name     | nm ([-_] nm)*

    - Token names and regexes, in order of evaluation:

        Tokens            | Pattern
        ------------------------------------------
        quoted-literal    | '[^']+?'
        whitespace        | \s+         emit=False
        quantifier-range  | \{ \s* ( \d+ | \d+ \s* , | \d+ \s* , \s* \d+ ) \s* \}
        paren-open        | \(
        paren-close       | \)
        brack-open        | \[
        brack-close       | \]
        brace-open        | \{
        brace-close       | \}
        angle-open        | \<
        angle-close       | \>
        choice-sep        | BAR
        zero-or-more      | \*
        one-or-more       | +
        one-or-more-dots  | \.\.\.
        question          | \?
        long-option       | -- name
        short-option      | - letter
        partial-defintion | name ` \s* :
        variant-defintion | name \s* :
        continuation      | :
        partial-usage     | name `
        destination       | name \s* =
        name              | name
        number            | \d+
        nameless-param    | _

Phase 3: parsing:

    - A parser's job is to eat a stream of tokens, organizing them into
      meaningful and valid units, and emitting those units to the caller.

        - Previously, I tried to write the lexer code with a parsing mindset.
          That was too hard.

        - Now we just have to figure out how to organize the consumption of the
          tokens listed above.

    - Focus now on the full grammar. Convenience syntax can be handle later via
      a different subclass, different tokens, different parser functions, or
      some combo.

    - Key points from current SimpleSpecParser:

        - Parser functions should be substantive from the perspective of the
          language, not low level.

        - Since a grammar is just a sequence of Variant, the GenericParserMixin
          will be given just one parser function. The more fine-grained method
          calling will occur in the subclass.

    - Parser functions:

        - Could this code be simplified by letting GenericParserMixin peek
          ahead 1 or more tokens. And the ability to retrieve tokens from the
          last peek. Basically, make GenericParserMixin better so the
          subclass code can be simplified.

        - Add a NL token: use it to increment manage (LINENO, COLUMN),
          for better error reporting.
            - Store (LINE, COL) in parsed entitities too?

        - Figure out all needed classes/data-objects:
            - Token types
            - Actual Grammar elements.
            - Parsed entitities: tokens parsed, but
              some post-processing still needed to created full
              Grammar elements.

        - Add ability to so self.eat(..., require = True|N)

        variant():
            # Variant name.
            tok = self.eat_first(variant-defintion, partial-defintion)
            if tok:
                var_name = ...
                is_partial = ...
            else:
                return None

            # Expressions.
            exprs = []
            while True:
                e = self.expression()
                if e:
                    exprs.push(e)
                else:
                    break

            return Variant(var_name, is_partial, exprs)

        expresion():
            elems = []
            while True:
                e = self.element()
                if e:
                    elems.push(e)
                else:
                    break
            return Expression(elems)

        element():
            e = None
            element_methods = [
                self.quoted_literal,
                self.partial_usage,
                self.paren_expression,
                self.brack_expression,
                self.positional,
                self.long_option,
                self.short_option,
            ]
            for method in element_methods:
                e = method()
                if e:
                    break
            if e:
                q = self.quantifier()
                if q:
                    e.quantifier = q
            return e

        paren_expression():
            return self.parenthesized(paren-open, paren-close, 'expression')

        brack_expression():
            return self.parenthesized(brack-open, brack-close, 'expression')

        quoted_literal():
            tok = self.eat(quoted-literal)
            if tok:
                return Literal(...)
            else:
                return None

        partial_usage():
            tok = self.eat(partial-usage)
            if tok:
                return PartialUsage(...)
            else:
                return None

        long_option():
            return self.option(long-option)

        short_option():
            return self.option(long-option)

        option(option_type):
            tok = self.eat(option_type)
            if not tok:
                return None
            name = ...
            params = []
            while True:
                p = self.parameter()
                if p:
                    params.append(p)
                else:
                    break
            return Opt(name, params, ...)

        positional():
            return self.parenthesized(angle-open, angle-close, 'positional_definition')

        parameter():
            return self.parenthesized(brace-open, brace-close, 'parameter_definition')

        positional_definition():
            # Destination assignment.
            tok = self.eat(destination)
            if tok:
                dest = ...
                choices = self.choices()
                if not choices:
                    raise ...
                elif len(choices) == 1:
                    return PositionalVariant(dest, value = ...)
                else:
                    return Positional(dest, choices = choices)
            # Simple positional.
            tok = self.eat(name)
            if tok:
                dest = ...
                return Positional(dest)
            else:
                raise ...

        parameter_definition():
            # TODO
            # -p {}        -p {x}        Parameter.
            # -p _         .             Parameter.
            # -p {=a|b}    -p {x=a|b}    Parameter choices.
            # -p {=foo}    -p {x=foo}    Parameter variant.

        choices():
            # TODO
            # 'literal value'
            # name

        quantifier():
            quantifier_methods = [
                self.one_or_more_dots,
                self.one_or_more,
                self.zero_or_more,
                self.zero_or_one,
                self.quantifier_range,
            ]
            for method in quantifier_methods:
                q = method()
                if q:
                    greedy = not self.eat(question)
                    return Quantifier(q, greedy)
            return None

        one_or_more_dots():
            tok = self.eat(one-or-more-dots)
            return (1, None) if tok else None

        one_or_more():
            tok = self.eat(one-or-more)
            return (1, None) if tok else None

        zero_or_more():
            tok = self.eat(zero-or-more)
            return (0, None) if tok else None

        zero_or_one():
            tok = self.eat(question)
            return (0, 1) if tok else None

        quantifier_range():
            tok = self.eat(quantifier-range)
            if tok:
                tup = ...
                return tup
            else:
                return None

        parenthesized(open_tok, close_tok, method_name):
            if self.current(open_tok):
                self.eat(open_tok)
                method = getattr(self, method_name)
                tok = method()
                if not tok:
                    raise ...
                if self.eat(close_tok):
                    return tok
                else:
                    raise ...
            else:
                return None

        TEMP:

            quoted-literal    | '[^']+?'
            whitespace        | \s+         emit=False
            quantifier        | .
            paren-open        | \(
            paren-close       | \)
            brack-open        | \[
            brack-close       | \]
            brace-open        | \{
            brace-close       | \}
            angle-open        | \<
            angle-close       | \>
            choice-sep        | BAR
            quant-sep         | ,
            one-or-more       | \.\.\.
            non-greedy        | \?
            long-option       | -- name
            short-option      | - letter
            partial-defintion | name ` \s* :
            variant-defintion | name \s* :
            continuation      | :
            partial-usage     | name `
            destination       | name \s* =
            name              | name
            number            | \d+
            nameless-param    | _

        Elem
            option
            positional
            parameter
            group: backet or paren
                Expression 1+

--------
syntax-examples: Syntax examples
--------

blort-maker:

    - This is generally a subcommand-style script, plus various bells and
      whistles to exercise most of the full grammar syntax.

    help`         : [--help] [--syntax]
    general`      : [--verbose] [--log-file {}] help`
    other`        : [--hi] [--bye]

    configure     : help` general` <task=configure> --odin-env {} --od-user {}
    submit        : help` general` <task=submit> -c {} -r {} [--start-job] [--person {name} {age}]
    get           : help` general` <task=get> -j {} [--json [--indent {}] | --b64 | --yaml]
    drop          : help` general` <task=drop> <what=first|last|random> [--print] <n>
    fubb          : help` other` [-a] [-b] <fubb>... (--fast | --slow)
    zzz           : help` other` [-x] [-y] items=(<a> <b> <c> [-z]){2,7}

neck-diagram:

    - This is a non-standard command line program: its grammar consists of one
      or more subcommands with a literal separator between them.

    cmd` :  commands=(
                <cmd=snum>   <snum>             |
                <cmd=fnum>   <fnum>             |
                <cmd=number> <numbering=on|off> |
                <cmd=tuning> <notes>...         |
                <cmd=fret>   <syms>...          |
                <cmd=invert> <syms>...
            )...

    main : cmd` [ '/' cmd` ]...

Sytax example: nab:

    - Another separator-based grammar.
    - But an interesting separator.

    cmd` : '-s' <cmd=chomp>                          |
           '-s' <cmd=findall> <rgx>                  |
           '-s' <cmd=grep> <rgx> [-i] [-v] [-s]      |
           '-s' <cmd=range> <start> <stop> [<step>]  |
           '-s' <cmd=run> <code> [-g {}] [-a]

    main : [--help] commands=cmd`...

--------
single-opt-convenience-syntax: Convenience syntax for single Opts
--------

    Convenience syntax when configuring a single Opt:

        x x [x]     Positionals can drop <> brackets.
        x=a|b|c     Ditto, with choices.
        -f _ [_]    Parameters can drop {} brackets.
        -f a b      Ditto, with named parameters.

        - Some examples using full syntax:

            Opt('<what>')
            Opt('<what=first|last|random>')
            Opt('<x> <x> [<x>]')
            Opt('--foo')
            Opt('--foo {} {} [{}]')
            Opt('--foo {a} {b} [{c}]')

        - Same examples using convenience syntax, which drops the explicit
          brackets for positionals and parameters.

            Opt('what')
            Opt('what=first|last|random')
            Opt('x x [x]')
            Opt('--foo')
            Opt('--foo _ _ [_]')
            Opt('--foo a b [c]')

--------
terminology: Terminology
--------

Users:

    - Library: the optopus code base.
    - Library user (or just user): a developer using optopus.
    - End user: a user running a program that uses optopus.

Command line argument types:

    - Arguments:
        - The raw strings directly from the command line.

    - Positionals:
        - The typical non-option argument.

    - Options: arguments with an option prefix.

        - Long prefix.
        - Short prefix.

        - Option (parameter option)
        - Flag


    - Parameters:
        - Arguments for an option.

    - Positional or parameter variant:
        - Mechanism to define a special grammar when a
          positional or parameter takes a specific value.

Help text sections:

    - Terminology in this project:
        - Usage text: conveys the command-line grammar.
        - Options text: documents the options and positional arguments, perhaps in groups.
        - Custom sections.

    - Command line style:
        - Usage.
        - Positional arguments.
        - Options and/or option groups.
        - Custom sections.

    - Man-page style:

        - NAME
        - SYNOPSIS
        - DESCRIPTION
        - OPTIONS
        - Custom sections.

Destination assignment:

    - Controls how the parsed data elements are stored and named.

--------
old-api-examples: Old API examples
--------

NEEDS EDITING PASS

When working on the Parser API, also see odin-client-via-api. It's
somewhat out of date but might have useful ideas.

####
# Parser.
####

p = Parser()

p.parse(args = None)
p.parse_known(args = None)
p.help_text(section = None)
p.error_text()
p.warn(msg)
p.error(code = None, msg = None))
p.exit(code = None, msg = None)

####
# Opts.
####

o = Opt(
    option     = '--job-id',            # Or string-spec with option, aliases, and arg_name.
    aliases    = ['-j', '-J', '--jid'], # Or just one string.
    n_args     = 1,
    repeatable = False,                 # If true, append values.
    choices    = ('A', 'B', 'C', 'D'),
    required   = False,
    tolerant   = False,                 # Setting option makes grammar fully tolerant.
    high       = False,                 # A high-precedence option (eg --help).
    greedy     = True,                  # Affects options arg consumption.
)

####
# Examples.
####

p = Parser(
    # Via simple Opt.
    Opt('--since TERM', type = int, default = 123),
    Opt('--limit N', type = int, default = 0),
    Opt('--rebuild'),
    Opt('--experiment EXP'),
    Opt('--stats'),
    Opt('--month M'),
    Opt('--search TERM', repeatable = True),
    Opt('--get ITEM'),

    # Via full Opts.
    Opt(
        'task',
        choices = 'configure submit upload start get stop download find'.split(),
        desc    = 'The odin-client task to run',
    ),

    # Via dict.
    dict(
        option  = '--odin-env ENV',
        groups  = 'general',
        default = 'dev',
        desc    = "Odin environment ('production' for most users).",
    ),

    parsing_config = {
        allow_abbrev = True,
        opt_prefix_rgx = ...,
    },

    formatter_config = {
        program_name = '...',
        etc ...
    },

)

# All help-text section, in order.
p.help_text()

# Specific help-text sections, in the requested order.
p.help_text('usage')
p.help_text('section-foo')
p.help_text('section-foo', 'section-bar')

####
# SimpleSpec.
####

VERDICT: dropping this concept.

For example:

    --verbose --type A <x> <y> -h -g

    spec = '-n NAME --foo --bar B1 B2 <x> <y>'
    p = parser(simple = spec)


    expr        = (longoption | shortoption | posarg)+

    longoption  = longopt optarg*
    shortoption = shortopt optarg*
    posarg      = "<" char+ ">"

    longopt     = "--" char+
    shortopt    = "-" char
    optarg      = [A-Z_\-\d]+
    char        = [\w\-]

Elements:

    short opt  | -h
    long opt   | --type
    opt arg    | A
    positional | <x>


# Creating a Grammar via the API

    general_opts = Partial(
        'general',
        Opt('--verbose'),
        Opt('--log-file {}'),
    )

    other_opts = Partial(
        'other',
        Opt('--hi'),
        Opt('--bye'),
    )

    task_opt = Opt(
        'task',
        choices = ('configure', 'submit', 'get', 'drop'),
    )

    general_zone = Zone(general_opts)

    variants = [
        Variant(
            'configure',
            general_zone,
            Zone(
                Choice(task_opt, value = 'configure', anchor = True),
                Opt('--odin-env {}', required = True),
                Opt('--od-user {}', required = True),
            ),
        ),
        Variant(
            'submit',
            general_zone,
            Zone(
                Choice(task_opt, value = 'submit', anchor = True),
                Opt('-c {}', required = True),
                Opt('-r {}', required = True),
                Opt('--start-job'),
                Opt('--person {name} {age}'),
            ),
        ),
        Variant(
            'get',
            general_zone,
            Zone(
                Choice(task_opt, value = 'get', anchor = True),
                Opt('-j {}', required = True),
                Alternatives(
                    Group(
                        Opt('--json', required = True),
                        Opt('--indent {}'),
                    ),
                    Opt('--b64'),
                    Opt('--yaml'),
                    required = False,
                ),
            ),
        ),
        Variant(
            'drop',
            general_zone,
            Zone(
                Choice(task_opt, value = 'drop', anchor = True),
                Opt('what', choices = ('first', 'last', 'random'), required = True),
                Opt('--print'),
                Opt('n'),
            ),
        ),
        Variant(
            'fubb',
            Opt('-a'),
            Opt('-b'),
            other_opts,
            Opt('fubb', nargs = (1, None)),
            Alternatives(
                Opt('--fast'),
                Opt('--slow'),
            ),
        ),
        Variant(
            'zzz',
            Opt('-x'),
            Opt('-y'),
            other_opts,
            Group(
                Opt('a'),
                Opt('b'),
                Opt('c'),
                Opt('-z'),
                ntimes = (2, 7),
            ),
        ),
        Variant(
            'help',
            Opt('--help', high = True),
        ),
    ]

API: FormatterConfig example:

    p = Parser(

        Opt(
            '--blort',
            text = '',
            sections = ['foo', 'bar'],             # Can be str or list/tuple/set.
        ),

        formatter_config = FormatterConfig(

            # Either Section or iterable.
            # Default label: "Foo options"
            Section('usage', label = '...'),
            Section('foo'),
            Section('bar'),
            Section('short-opts'),
            Section('special-notes', text = SPECIAL_NOTES, label = 'Special notes'),
            Section('warnings', text = WARNINGS, label = 'Warnings'),

            program_name        = '',
            section_label_punct = ':',
            after_section_label = '',
            after_section       = '\n',

            program_summary    = '',
            style              = CLI|MAN,
            opt_style          = CLI|MAN,

        ),

    )

    Section
        name  | Short; used symbolically (eg in grammar).
        label | Used in help text

API needs good syntax for retrieving grammar elements:

    g.get(NAME, NAME, ...)          # Get one.
    g.get(NAME, [NAME, ...], ...)   # Get multiple.

    - Support bulk configuration.

    - In user validation code, they need an easy way to get sibling Opt
      information.

Function signature for converters and validators:

    Function  | Arity | Signature
    -------------------------------------------------------
    Converter | 1     | STR            => OBJ/raise
    Validator | 3     | VAL, OPT, OPTS => True/False/raise
    Dispatch  | 3     | VAL, OPT, OPTS => None

--------
classes-and-attributes: Classes and attributes
--------

Parser:

    Attribute        | Note
    --------------------------------------------------------------------------------
    grammar          | Was 'simple_spec'.
    elems            | Was 'opts'.
    --------------------------------------------------------------------------------
    sections         | Defer.
    program          | Defer. The program name, in usage text.
    formatter_config | Defer. FormatterConfig.
    add_help         | Defer.
    --------------------------------------------------------------------------------
    wildcards        | Drop. Was used to support * as a match-anything device.
    --------------------------------------------------------------------------------

Opt:

    Attribute | Note
    --------------------------------------------------------------------------------
    grammar   | Grammar syntax for the Opt. Was 'option_spec'.
    ntimes    | .
    nargs     | .
    nparams   | .
    dest      | Was 'destination'.
    default   | .
    convert   | Callable(s).
    validate  | Callable(s).
    --------------------------------------------------------------------------------
    text      | Defer.
    aliases   | Defer.
    high      | Defer. Was 'tolerant'.
    factory   | Defer. Callable to create default.
    dispatch  | Defer. Callable(s).
    choices   | Defer. Could handle with validate.
    sections  | Defer. Sequence of section names.
    required  | Defer, maybe drop. Same as ntimes=1.
    negaters  | Defer. For flag negatives (to overrule True default)
    hidden    | Defer.
    help      | Defer. For help dispatching. Maybe handle via dispatch attribute.
    --------------------------------------------------------------------------------
    option    | Internal. Not sure of purpose.
    _opt_type | Internal. Holds an OptType.
    arg_names | Internal. Seems related to simple spec parsing.
    --------------------------------------------------------------------------------

Result:

    - Data object returned to end-user by Parser.parse().

    - A mapping-like object with destinations as the attributes.

Target:

    - A data object used during argument parsing to store the
      information ultimately returned as a Result to end user.

    - For the applicable parsing interpretation, a Target contains information
      about all relevant Opt/Pos and values parsed so far.

    Attribute   | Note
    --------------------------------------------------------------------------------
    positionals | List[Pos]
    options     | Dict[Opt]
    values      | Dict[DEST -> VAL]
    --------------------------------------------------------------------------------

TokenType:

    - Internal data object given to a lexer.

    Attribute | Note
    --------------------------------------------------------------------------------
    name      | Name of token.
    rgx       | Regex to match the token.
    emit      | Whether to emit back to parser [default: True].
    --------------------------------------------------------------------------------

RegexLexer:

    - General-purpose regex-based lexer.

    Attribute   | Note
    --------------------------------------------------------------------------------
    text        | The text to be lexed.
    token_types | Sequence of TokenType.
    pos         | Current index of the lexer.
    max_pos     | Last index of the text.
    is_eof      | Becomes True when text exhausted.
    --------------------------------------------------------------------------------

Token:

    - Simple internal data object emitted by a lexer.

    Attribute  | Note
    --------------------------------------------------------------------------------
    token_type | TokenType of the token.
    value      | Corresponding token text.
    --------------------------------------------------------------------------------

GenericParserMixin:

    - Provides parse(), eat(), and error() behaviors.

    Attribute        | Note
    --------------------------------------------------------------------------------
    lexer            | Lexer, supplied by subclass.
    parser_functions | Sequence of token-eating functions, supplied by subclass.
    --------------------------------------------------------------------------------
    current_token    | Managed by the mixin.
    --------------------------------------------------------------------------------

GrammarParser:

    TODO

State:

    - Internal object used during parsing: see arg-parsing-algo .

ArgResult:

    - Internal object used during parsing: see arg-parsing-algo .

--------
deferred-classes: Deferred classes
--------

ParsedOptions
    - Object returned by Parser.parse().
    - Basic form: self.DESTINATION = VALUE.
    - Also behaves like a collection: iterable, dictable, etc.

    args
    parsed_opts
    args_index

ParsedOpt
    - Used by the Parser to store parsing results for an Opt.
    - Each ParsedOpt represents one DESTINATION-VALUE pair.

    destination
    opt
    _values

FormatterConfig
    - Object for the user to configure details about the generation
    - of usage and help text.

    sections
    program_name
    section_label_punct
    after_section_label
    after_section
    program_summary
    style
    opt_style
    alias_style

Section
    - Used to create labeled groups of Opt instances for the purposes
    - of help text generation.

    name
    label
    text
    opts

SimpleSpecParserGenericParser(GenericParserMixin)
    - Used to parse a simple grammar spec given by the user.
    - The parse() method returns a Phrase representing the CLI grammar.

GrammarSpecParser
    - Like SimpleSpecParser, but for the full variant-based grammar.
    # Not implemented yet.

Phrase
    - Object used by Parser to represent CLI grammar and do parsing work.
    - Each Phrase can store subphrases, so the grammar forms a tree.
    - Leaves are Phrase objects corresponding to Opt intances.

    subphrases
    opt

OptToken
    - A data object holding the parsed content of a Token.
    - Lacks constructor; should add.
    - Callers are using these attributes.

    option
    option_spec
    nargs
    opt_type
    arg_names

Enum
    - Used for collections of constants.
    - Should switch to short-con.

    _enum_name
    _members
    _rmembers

EnumMember
    - Used by Enum.
    - The kws dict is used to set as attributes on self.

    enum_name
    name
    value
    **kws

RegexLexerErrorException(Exception)
    pass

OptoPyErrorException(Exception)
    pass

