--------
grammar-syntax: Grammar syntax
--------

Overall structure:

    foo` : PARTIAL_DEFINITION
    bar  : VARIANT_DEFINITION

    Defintions can span multiple lines. Leading colon is required.

        foo` : Blah blah
             : blah blah
             : blah blah
        bar  : Blah

Variant definition syntax:

    Variants:

        foo`             Insert the foo partial into the current partial or variant.

    Grouping and alternatives:

        []               Grouping, optional.
        ()               Grouping.
        foo=[]           Named grouping, optional.
        foo=()           Named grouping.
        |                Alternatives.

    Quantifiers:

        ...              1 or more
        +                1 or more
        *                0 or more
        ?                0 or 1
        {m,n}            Repetition: m through n, inclusive.
        ?                Non-greedy for preceding quantifier.

    Positional arguments:

        <xy>             Positional.
        <xy=a|b>         Positional choices.
        <xy=foo>         Positional variant.

    Options:

        -x               Short.
        --xy             Long.

    Option parameters:

        Unnamed          Named
        --------------------------------------------------
        -p {}            -p {x}         Parameter.
        -p _             .              Parameter.
        -p {=a|b}        -p {x=a|b}     Parameter choices.
        -p {=foo}        -p {x=foo}     Parameter variant.

    Literals:

        'hello world'    Literal: can be used as positional, positional choice,
                         positonal variant, parameter choice, or parameter variant.

    Convenience syntax when configuring a single Opt:

        Positionals      Options
        --------------------------------------------------------
        x x [x]          -f _ [_]       Brackets/braces unneeded
        x=a|b|c          -f a|b         Choices.

    Whitespace rules:

        - Whitespace required:

            - Quoted literal containing whitespace (no user want this).

            - If a variant ends with an option, whitespace is needed before the
              next variant name (otherwise the names bleed together).

            - To disambiguate names in the convenience syntax for single Opts.

        - Tight-binding required among syntax elements:

            - Option prefix with name.

            - Partial name with back-quote (this could be optional, but
              there is no benefit).

--------
syntax-examples: Syntax examples
--------

blort-maker:

    - This is generally a subcommand-style script, plus various bells and
      whistles to exercise most of the full grammar syntax.

    help`         : [--help] [--syntax]
    general`      : [--verbose] [--log-file {}] help`
    other`        : [--hi] [--bye]

    configure     : help` general` <task=configure> --env {} --user {}
    submit        : help` general` <task=submit> -c {} -r {} [--start-job] [--person {name} {age}]
    get           : help` general` <task=get> -j {} [--json [--indent {}] | --b64 | --yaml]
    drop          : help` general` <task=drop> <what=first|last|random> [--print] <n>
    fubb          : help` other` [-a] [-b] <fubb>... (--fast | --slow)
    zzz           : help` other` [-x] [-y] items=(<a> <b> <c> [-z]){2,7}

neck-diagram:

    - This is a non-standard command line program: its grammar consists of one
      or more subcommands with a literal separator between them.

    cmd` :  commands=(
                <cmd=snum>   <snum>             |
                <cmd=fnum>   <fnum>             |
                <cmd=number> <numbering=on|off> |
                <cmd=tuning> <notes>...         |
                <cmd=fret>   <syms>...          |
                <cmd=invert> <syms>...
            )...

    main : cmd` [ '/' cmd` ]...

Sytax example: nab:

    - Another separator-based grammar.
    - But an interesting separator.

    cmd` : '-s' <cmd=chomp>                          |
           '-s' <cmd=findall> <rgx>                  |
           '-s' <cmd=grep> <rgx> [-i] [-v] [-s]      |
           '-s' <cmd=range> <start> <stop> [<step>]  |
           '-s' <cmd=run> <code> [-g {}] [-a]

    main : [--help] commands=cmd`...

--------
terminology: Terminology
--------

Users:

    - Library: the optopus code base.
    - Library user (or just user): a developer using optopus.
    - End user: a user running a program that uses optopus.

Command line argument types:

    - Arguments:
        - The raw strings directly from the command line.

    - Positionals:
        - The typical non-option argument.

    - Options: arguments with an option prefix.

        - Long prefix.
        - Short prefix.

        - Option (parameter option)
        - Flag

    - Parameters:
        - Arguments for an option.

    - Positional or parameter variant:
        - Mechanism to define a special grammar when a
          positional or parameter takes a specific value.

Help text sections:

    - Terminology in this project:
        - Help text: documents everything.
        - Usage text: documents the command-line grammar.
        - Options text: documents the options and positional arguments, perhaps in groups.
        - Custom sections.

    - Command line style:
        - Usage.
        - Positional arguments.
        - Options and/or option groups.
        - Custom sections.

    - Man-page style:

        - NAME
        - SYNOPSIS
        - DESCRIPTION
        - OPTIONS
        - Custom sections.

Destination assignment:

    - Controls how the parsed data elements are stored and named.

--------
classes-and-attributes: Classes and attributes
--------

Overview:

    User-facing entities:

        Parser
        Section
        Grammar
        Variant
        Group
        Opt
        Result
        Query

        Relationships:

            Parser
                sections      = List[Section]      # 0+
                grammar       = Grammar            # 0 or 1
                    variants  = List[Variant]      # 0+
                        elems = List[Group or Opt] # 0+

                parse(ARGS) -> Result

            Group:
                elems = List[Group or Opt] # 0+

    Objects used during grammar parsing:

        GrammarParser      | Parses a spec, returns Grammar.
        RegexLexer         | Lexer used by GrammarParser.
        TokType            | Token types given to lexer.
        Token              | Emitted by lexer.
        ParseElem          | Emitted by parser functions. Later assembled into Grammar.

    Objects used during argument parsing:

        State
        ArgResult
        Target

    Entities used only for notation:

        PartialUsage      | Group
        Positional        | Opt
        PositionalVariant | Opt
        ParameterVariant  | Opt

Parser:

    - Class will likely have various getters or query functionality to make it
      easy to configure specific grammar elements. Users should not have to
      manually navigate the Grammar hierarchy very often.

    Attribute | Note
    --------------------------------------------------------------------------------
    spec      | Was 'simple_spec'.
    grammar   | Grammar. Was 'opts'.
    mode      | Special parsing mode.
    --------------------------------------------------------------------------------
    auto      | Defer. True by default: exit with error on failed parse().
    sections  | Defer.
    format    | Defer. Data object to namepsace formatting attributes. Was 'formatter_config'.
    helpful   | Defer.
    --------------------------------------------------------------------------------
    prog      | Drop. Handled via the spec or under format.
    wildcards | Drop. Was used to support * as a match-anything device.
    --------------------------------------------------------------------------------

    API:

        - Parsing:

            Parser(spec = None, grammar = None, ...)

                - The spec/grammar arguments are mutex and optional.
                - Other arguments are defferred.

            parse(args = None, mode = ...) -> Result or raise

                - Parser can have a mode.
                - And parse() can temporarily use a different mode.

        - Querying and configuring grammar elements:

            query(*paths, **kws) -> Grammar.query(...) -> Query

                - Query paths are based on Opt.dest, Variant.name, and
                  Group.dest or Group.index.

                - The vast majority of queries will be for leaf nodes: the
                  Opts.

                    query('foo', 'bar')

                    - Gets Opt(foo) and Opt(bar).

                    - More precisely, the query gets any grammar element having
                      those dests/names.

                - In complex cases where independent Opts have the same dest,
                  the query path can include the variant name.

                    query('go foo')

                    - Gets Opt(foo) inside Variant(go).

                - Although Groups can have a dest, most won't. But they will
                  have a unique index within each variant.

                    query('go 2')

                    - Gets the third Group in Variant(go).

                - As a future enhancement, these query path elements can be
                  interpreted as regular expressions (I doubt the need).

            config(*paths, **kws) -> None

                - Given Opts, configure them all in the same way.

                - Just a shortcut for query(*paths).config(**kws).

            config_each(attr_name, d) -> None

                - Given Opts, set one attribute in different ways
                  for each opt.

                - The second argument is a dict mapping query paths to the
                  desired value for the attribute.

                - For example, setting a bunch of Opt.text values:

                    config_each('text', {
                        'foo': 'Blah',
                        'bar': 'Blah blah',
                    })

        - Obtaining help text or text for the error from most recent parse():

            help_text(section...)
            error_text
            exception

        - Actions like printing or exiting.

            warn(msg)
            help(section...)
            error(msg = None, code = 1)
            exit(msg = None, code = 0)

Section

    - Used to create labeled groups of Opt for help text purposes.
    - Each variant has a corresponding section with the same name.

    Attribute | Note
    --------------------------------------------------------------------------------
    name      | Short symbolic name used in API.
    label     | Used in help text.
    opts      | Opts belonging to the section.
    text      | Hand-crafted help text.
    --------------------------------------------------------------------------------

Grammar:

    Attribute | Note
    --------------------------------------------------------------------------------
    variants  | List[Variant]
    --------------------------------------------------------------------------------

    API:

        query(*paths, kind = KIND, negate = False) -> Query

Query:

    Iterable tuple-like object returned by Grammar.query(). Holds the Groups/Opts
    that satisfy the search parameters. Supports bulk configuration.

    Attribute | Note
    --------------------------------------------------------------------------------
    elems     | List[Group or Opt]
    --------------------------------------------------------------------------------

    API:

        config(...) # Apply the config parameters to all Groups/Opts.
        query(...)  # Subquery to filter down further.

Variant:

    Attribute | Note
    --------------------------------------------------------------------------------
    elems     | List[Group or Opt]
    ntimes    | .
    --------------------------------------------------------------------------------

Group:

    Attribute | Note
    --------------------------------------------------------------------------------
    elems     | List[Group or Opt]
    ntimes    | .
    validate  | Defer. Callable(s).
    --------------------------------------------------------------------------------

Opt:

    - A configurable data object to represent one option (with parameters,
      quantifiers) or one positional (with quantifiers).

    Attribute | Note
    --------------------------------------------------------------------------------
    spec      | Was 'option_spec'.
    grammar   | Grammar.
    ntimes    | .
    nargs     | .
    nparams   | .
    dest      | Was 'destination'.
    default   | .
    value     | None (typical) or the variant value.
    choices   | None (validation deferred).
    --------------------------------------------------------------------------------
    help      | Defer. For help dispatching. Maybe handle via dispatch attribute.
    metavar   | Defer. But need a better name.
    choices   | Defer.
    convert   | Defer. Callable.
    validate  | Defer. Callable.
    text      | Defer.
    hide      | Defer. False (visible), True (hidden), or sequence of where/what to hide
    sections  | Defer. Sequence of section names.
    high      | Defer. Was 'tolerant'.
    factory   | Defer. Callable to create default.
    aliases   | Defer.
    dispatch  | Defer. Callable(s). Maybe 'actions'.
    required  | Defer, maybe drop. Same as ntimes=1.
    negaters  | Defer. For flag negatives (to overrule True default)
    case      | Defer. Case-sensitive if True.
    anchor    | Defer. bool
    --------------------------------------------------------------------------------
    option    | Internal. Not sure of purpose.
    _opt_type | Internal. Holds an OptType.
    arg_names | Internal. Seems related to simple spec parsing.
    --------------------------------------------------------------------------------

    For options taking multiple parameters or positionals having multiple
    arguments, the most common use case treats the parameters/arguments as
    values of the same kind -- meaning that that have the same type, defaults,
    choices, conversion, validation, etc. However, sometimes users want those
    characteristics to vary. In that case, the following attributes also
    support a sequence of values, one per parameter/argument. In cases where
    the nparams/nargs have no upper bound, the last value in the sequence will
    be applied: for example, if nparams=(2,None) one could use convert=(float,
    int), which would use int to convert any parameters beyond the second.

        dest      # Needed only for parameters.
        metavar
        ----
        default
        factory
        value
        ----
        choices
        convert
        validate

    API:

        config(...)

Result:

    - Data object returned to end-user by Parser.parse().

    - An iterable mapping-like object with destinations as the attributes.

GrammarParser:

    Attribute | Note
    --------------------------------------------------------------------------------
    lexer     | Lexer.
    handlers  | Sequence of token-stream handlers. Was 'parser_functions'.
    curr      | Was 'current_token'. Managed by the mixin.
    prevpeek  | .
    --------------------------------------------------------------------------------

    API:

        parse()
        eat()
        error()

RegexLexer:

    - General-purpose regex-based lexer.

    Attribute | Note
    --------------------------------------------------------------------------------
    text      | The text to be lexed.
    toktypes  | Sequence of TokType.
    pos       | Current index of the lexer.
    mxpos     | Last index of the text.
    iseof     | Becomes True when text exhausted.
    --------------------------------------------------------------------------------

    API:

        See _old.py implementation and modifications in _draft.py.

TokType:

    - Internal data object given to a lexer.

    Attribute | Note
    --------------------------------------------------------------------------------
    name      | Name of token.
    regex     | Regex to match the token.
    emit      | Whether to emit back to parser [default: True].
    --------------------------------------------------------------------------------

    Kinds:

        See grammar-parsing-algo notes.

Token:

    - Simple internal data object emitted by a lexer.

    Attribute | Note
    --------------------------------------------------------------------------------
    toktype   | TokType of the token.
    value     | Corresponding token text.
    pos       | Position (where matched)
    line      | Line number.
    col       | Column number.
    --------------------------------------------------------------------------------

    Kinds:

        Same as TokType.

ParseElem:

    - Simple internal data object emitted by the parsing phase of
      GrammarParser.parse(). Subsequent work in that method will convert the
      ParseElem into a user-facing Grammar.

    Kinds:

        variant
        group
        opt
        quantifier
        choices
        parameter
        literal

State:

    - An internal data object used during argument parsing. See
      arg-parsing-algo notes.

ArgResult:

    - An internal data object used during argument parsing. See
      arg-parsing-algo notes.

Target:

    - A data object used during argument parsing to store the
      information ultimately returned as a Result to end user.

    - For the applicable parsing interpretation, a Target contains information
      about all relevant Opt/Pos and values parsed so far.

    Attribute | Note
    --------------------------------------------------------------------------------
    poss      | List[Pos]
    opts      | Dict[Opt]
    vals      | Dict[DEST -> VAL]
    --------------------------------------------------------------------------------

