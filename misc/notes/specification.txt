--------
grammar-syntax: Grammar syntax
--------

Overall structure:

    foo` : PARTIAL_DEFINITION
    bar  : VARIANT_DEFINITION

    Defintions can span multiple lines. Leading colon is required.

        foo` : Blah blah
             : blah blah
             : blah blah
        bar  : Blah

Variant definition syntax:

    Variants:

        foo`        Insert the foo partial into the current partial or variant.

    Grouping and alternatives:

        []          Grouping, optional.
        ()          Grouping.
        foo=[]      Named grouping, optional.
        foo=()      Named grouping.
        |           Alternatives.

    Quantifiers:

        ...         1 or more
        {m,n}       Repetition: m through n, inclusive.
        ?           Non-greedy quantifier.

    Positional arguments:

        <xy>        Positional.
        <xy=a|b>    Positional choices.
        <xy=foo>    Positional variant.
        'bar'       Literal.

    Options:

        -x          Short.
        --xy        Long.

    Option parameters:

        Unnamed      Named
        ---------------------------------------------
        -p {}        -p {x}        Parameter.
        -p {=a|b}    -p {x=a|b}    Parameter choices.
        -p {=foo}    -p {x=foo}    Parameter variant.

    Convenience syntax when configuring a single Opt:

        Positionals    Options
        ---------------------------------------------------
        x x [x]        -f _ [_]    Brackets/braces unneeded
        x=a|b|c        -f a|b      Choices.
        x=a            -f x=a      Variant.

    Whitespace rules:

        - Whitespace required:

            - Quoted literal containing whitespace (no user want this).

            - If a variant ends with an option, whitespace is needed before the
              next variant name (otherwise the names bleed together).

            - To disambiguate names in the convenience syntax for single Opts.

        - Tight-binding required among syntax elements:

            - Option prefix with name.

            - Partial name with back-quote (this could be optional, but
              there is no benefit).

--------
parsing-grammar-syntax: Parsing the grammar syntax
--------

Phase 1: input normalization:

    - Accept text and/or lines of text.
    - Join into a block of text.

Phase 2: lexing:

    - Remember that the lexer analyzes character by character to emit
      the meaningful atomic units of the language.

    - It does not engage in validation logic to assess whether the arrangement
      of those units is syntactically valid.

    - Nor does it try to assemble those character-based atoms into fully
      meaningful entitities, other than in cases where they must be assemble to
      avoid ambiguitity with similar tokens.

    - Regex snippets to build the token regexes:

        Spippets | Pattern
        ------------------------------------------
        letter   | [A-Za-z]
        nm       | letter (letter | \d)*
        name     | nm ([-_] nm)*

    - Token names and regexes, in order of evaluation:

        Tokens            | Pattern
        ------------------------------------------
        quoted-literal    | '[^']+?'
        whitespace        | \s+         emit=False
        quantifier        | \{ \s* ( \d+ | \d+ \s* , | \d+ \s* , \s* \d+ ) \s* \}
        paren-open        | \(
        paren-close       | \)
        brack-open        | \[
        brack-close       | \]
        brace-open        | \{
        brace-close       | \}
        angle-open        | \<
        angle-close       | \>
        choice-sep        | BAR
        quant-sep         | ,
        one-or-more       | \.\.\.
        non-greedy        | \?
        long-option       | -- name
        short-option      | - letter
        partial-defintion | name ` \s* :
        variant-defintion | name \s* :
        continuation      | :
        partial-usage     | name `
        destination       | name \s* =
        name              | name
        number            | \d+
        nameless-param    | _

Phase 3: parsing:

    - A parser's job is to eat a stream of tokens, organizing them into
      meaningful and valid units, and emitting those units to the caller.

        - Previously, I tried to write the lexer code with a parsing mindset.
          That was too hard.

        - Now we just have to figure out how to organize the consumption of the
          tokens listed above.

    - Focus now on the full grammar. Convenience syntax can be handle later via
      a different subclass, different tokens, different parser functions, or
      some combo.

    - Key points from current SimpleSpecParser:

        - Parser functions should be substantive from the perspective of the
          language, not low level.

        - Remember also that GenericParserMixin calls the parser_functions in
          order. Try to work within that framework, if possible.

        - GenericParserMixin.parse() is what yields information back to the
          caller.

        - And the syntax grammar really only want to get back a sequence of 1+
          Variants and 0+ Partials -- which implies only two parser_functions,
          I think.

            variant()
            partial()

    - It seems like GenericParserMixin is not all that generic.

        - It operates on the model of a flat list of parser functions, but that
          approach does not work for anything other than flatt grammars.

        - We need more like a hierarchy of parser functions. Otherwise, we will
          need to implement logic very similar to GenericParserMixin in the
          subclass -- namely, the ability to try to parse different elements
          until one matches.

    - Hierarchy of parser functions:

        variant():
            # Variant name.
            tok = self.eat_first(variant-defintion, partial-defintion)
            if tok:
                var_name = ...
                is_partial = ...
            else:
                return None

            # Expressions.
            exprs = []
            while True:
                e = self.expression()
                if e:
                    exprs.push(e)
                else:
                    break

            return Variant(var_name, is_partial, exprs)

        expresion():
            elems = []
            while True:
                e = self.element()
                if e:
                    elems.push(e)
                else:
                    break
            return Expression(elems)

        element():
            # Get the syntax element or return None.
            if self.current(quoted-literal):
                # Literal
                e = ...

            elif self.current(paren-open):
                # Group: parens.
                tok = self.eat(paren-open)
                if not tok:
                    return None
                e = self.expresion()
                if not e:
                    return None
                tok = self.eat(paren-close)
                if not tok:
                    return None

            elif self.current(brack-open):
                # Group: brackets.
                Same pattern.

            elif self.current(brace-open):
                # Parameter.
                Same pattern.

            elif self.current(angle-open):
                # Positional.
                Same pattern.

            elif self.current(partial-usage):
                # Partial.
                e = ...

            elif self.current(long-option, short-option):
                # Option.
                e = ...

            # Quantifier.
            if e and self.current(quantifier):
                e.quantifier = ...

            return e

        TEMP:

            quoted-literal    | '[^']+?'
            whitespace        | \s+         emit=False
            quantifier        | .
            paren-open        | \(
            paren-close       | \)
            brack-open        | \[
            brack-close       | \]
            brace-open        | \{
            brace-close       | \}
            angle-open        | \<
            angle-close       | \>
            choice-sep        | BAR
            quant-sep         | ,
            one-or-more       | \.\.\.
            non-greedy        | \?
            long-option       | -- name
            short-option      | - letter
            partial-defintion | name ` \s* :
            variant-defintion | name \s* :
            continuation      | :
            partial-usage     | name `
            destination       | name \s* =
            name              | name
            number            | \d+
            nameless-param    | _

        x Grammar
        x     Variant +1
        x         Expression 1+
        .             Elements 1+
        -                 Elem
        -                 Quantifier {0,1}

        Elem
            quoted literal
            partial usage
            option
            positional
            parameter
            group: backet or paren
                Expression 1+

--------
syntax-examples: Syntax examples
--------

blort-maker:

    - This is generally a subcommand-style script, plus various bells and
      whistles to exercise most of the full grammar syntax.

    help`         : [--help] [--syntax]
    general`      : [--verbose] [--log-file {}] help`
    other`        : [--hi] [--bye]

    configure     : help` general` <task=configure> --odin-env {} --od-user {}
    submit        : help` general` <task=submit> -c {} -r {} [--start-job] [--person {name} {age}]
    get           : help` general` <task=get> -j {} [--json [--indent {}] | --b64 | --yaml]
    drop          : help` general` <task=drop> <what=first|last|random> [--print] <n>
    fubb          : help` other` [-a] [-b] <fubb>... (--fast | --slow)
    zzz           : help` other` [-x] [-y] items=(<a> <b> <c> [-z]){2,7}

neck-diagram:

    - This is a non-standard command line program: its grammar consists of one
      or more subcommands with a literal separator between them.

    cmd` :  commands=(
                <cmd=snum>   <snum>             |
                <cmd=fnum>   <fnum>             |
                <cmd=number> <numbering=on|off> |
                <cmd=tuning> <notes>...         |
                <cmd=fret>   <syms>...          |
                <cmd=invert> <syms>...
            )...

    main : cmd` [ '/' cmd` ]...

Sytax example: nab:

    - Another separator-based grammar.
    - But an interesting separator.

    cmd` : '-s' <cmd=chomp>                          |
           '-s' <cmd=findall> <rgx>                  |
           '-s' <cmd=grep> <rgx> [-i] [-v] [-s]      |
           '-s' <cmd=range> <start> <stop> [<step>]  |
           '-s' <cmd=run> <code> [-g {}] [-a]

    main : [--help] commands=cmd`...

--------
single-opt-convenience-syntax: Convenience syntax for single Opts
--------

    Convenience syntax when configuring a single Opt:

        x x [x]     Positionals can drop <> brackets.
        x=a|b|c     Ditto, with choices.
        -f _ [_]    Parameters can drop {} brackets.
        -f a b      Ditto, with named parameters.

        - Some examples using full syntax:

            Opt('<what>')
            Opt('<what=first|last|random>')
            Opt('<x> <x> [<x>]')
            Opt('--foo')
            Opt('--foo {} {} [{}]')
            Opt('--foo {a} {b} [{c}]')

        - Same examples using convenience syntax, which drops the explicit
          brackets for positionals and parameters.

            Opt('what')
            Opt('what=first|last|random')
            Opt('x x [x]')
            Opt('--foo')
            Opt('--foo _ _ [_]')
            Opt('--foo a b [c]')

--------
terminology: Terminology
--------

Users:

    - Library: the optopus code base.
    - Library user (or just user): a developer using optopus.
    - End user: a user running a program that uses optopus.

Command line argument types:

    - Arguments:
        - The raw strings directly from the command line.

    - Positionals:
        - The typical non-option argument.

    - Options: arguments with an option prefix.

        - Long prefix.
        - Short prefix.

        - Option (parameter option)
        - Flag


    - Parameters:
        - Arguments for an option.

    - Positional or parameter variant:
        - Mechanism to define a special grammar when a
          positional or parameter takes a specific value.

Help text sections:

    - Terminology in this project:
        - Usage text: conveys the command-line grammar.
        - Options text: documents the options and positional arguments, perhaps in groups.
        - Custom sections.

    - Command line style:
        - Usage.
        - Positional arguments.
        - Options and/or option groups.
        - Custom sections.

    - Man-page style:

        - NAME
        - SYNOPSIS
        - DESCRIPTION
        - OPTIONS
        - Custom sections.

Destination assignment:

    - Controls how the parsed data elements are stored and named.

--------
old-api-examples: Old API examples
--------

NEEDS EDITING PASS

When working on the Parser API, also see odin-client-via-api. It's
somewhat out of date but might have useful ideas.

####
# Parser.
####

p = Parser()

p.parse(args = None)
p.parse_known(args = None)
p.help_text(section = None)
p.error_text()
p.warn(msg)
p.error(code = None, msg = None))
p.exit(code = None, msg = None)

####
# Opts.
####

o = Opt(
    option     = '--job-id',            # Or string-spec with option, aliases, and arg_name.
    aliases    = ['-j', '-J', '--jid'], # Or just one string.
    n_args     = 1,
    repeatable = False,                 # If true, append values.
    choices    = ('A', 'B', 'C', 'D'),
    required   = False,
    tolerant   = False,                 # Setting option makes grammar fully tolerant.
    high       = False,                 # A high-precedence option (eg --help).
    greedy     = True,                  # Affects options arg consumption.
)

####
# Examples.
####

p = Parser(
    # Via simple Opt.
    Opt('--since TERM', type = int, default = 123),
    Opt('--limit N', type = int, default = 0),
    Opt('--rebuild'),
    Opt('--experiment EXP'),
    Opt('--stats'),
    Opt('--month M'),
    Opt('--search TERM', repeatable = True),
    Opt('--get ITEM'),

    # Via full Opts.
    Opt(
        'task',
        choices = 'configure submit upload start get stop download find'.split(),
        desc    = 'The odin-client task to run',
    ),

    # Via dict.
    dict(
        option  = '--odin-env ENV',
        groups  = 'general',
        default = 'dev',
        desc    = "Odin environment ('production' for most users).",
    ),

    parsing_config = {
        allow_abbrev = True,
        opt_prefix_rgx = ...,
    },

    formatter_config = {
        program_name = '...',
        etc ...
    },

)

# All help-text section, in order.
p.help_text()

# Specific help-text sections, in the requested order.
p.help_text('usage')
p.help_text('section-foo')
p.help_text('section-foo', 'section-bar')

####
# SimpleSpec.
####

VERDICT: dropping this concept.

For example:

    --verbose --type A <x> <y> -h -g

    spec = '-n NAME --foo --bar B1 B2 <x> <y>'
    p = parser(simple = spec)


    expr        = (longoption | shortoption | posarg)+

    longoption  = longopt optarg*
    shortoption = shortopt optarg*
    posarg      = "<" char+ ">"

    longopt     = "--" char+
    shortopt    = "-" char
    optarg      = [A-Z_\-\d]+
    char        = [\w\-]

Elements:

    short opt  | -h
    long opt   | --type
    opt arg    | A
    positional | <x>


# Creating a Grammar via the API

    general_opts = Partial(
        'general',
        Opt('--verbose'),
        Opt('--log-file {}'),
    )

    other_opts = Partial(
        'other',
        Opt('--hi'),
        Opt('--bye'),
    )

    task_opt = Opt(
        'task',
        choices = ('configure', 'submit', 'get', 'drop'),
    )

    general_zone = Zone(general_opts)

    variants = [
        Variant(
            'configure',
            general_zone,
            Zone(
                Choice(task_opt, value = 'configure', anchor = True),
                Opt('--odin-env {}', required = True),
                Opt('--od-user {}', required = True),
            ),
        ),
        Variant(
            'submit',
            general_zone,
            Zone(
                Choice(task_opt, value = 'submit', anchor = True),
                Opt('-c {}', required = True),
                Opt('-r {}', required = True),
                Opt('--start-job'),
                Opt('--person {name} {age}'),
            ),
        ),
        Variant(
            'get',
            general_zone,
            Zone(
                Choice(task_opt, value = 'get', anchor = True),
                Opt('-j {}', required = True),
                Alternatives(
                    Group(
                        Opt('--json', required = True),
                        Opt('--indent {}'),
                    ),
                    Opt('--b64'),
                    Opt('--yaml'),
                    required = False,
                ),
            ),
        ),
        Variant(
            'drop',
            general_zone,
            Zone(
                Choice(task_opt, value = 'drop', anchor = True),
                Opt('what', choices = ('first', 'last', 'random'), required = True),
                Opt('--print'),
                Opt('n'),
            ),
        ),
        Variant(
            'fubb',
            Opt('-a'),
            Opt('-b'),
            other_opts,
            Opt('fubb', nargs = (1, None)),
            Alternatives(
                Opt('--fast'),
                Opt('--slow'),
            ),
        ),
        Variant(
            'zzz',
            Opt('-x'),
            Opt('-y'),
            other_opts,
            Group(
                Opt('a'),
                Opt('b'),
                Opt('c'),
                Opt('-z'),
                ntimes = (2, 7),
            ),
        ),
        Variant(
            'help',
            Opt('--help', high = True),
        ),
    ]

API: FormatterConfig example:

    p = Parser(

        Opt(
            '--blort',
            text = '',
            sections = ['foo', 'bar'],             # Can be str or list/tuple/set.
        ),

        formatter_config = FormatterConfig(

            # Either Section or iterable.
            # Default label: "Foo options"
            Section('usage', label = '...'),
            Section('foo'),
            Section('bar'),
            Section('short-opts'),
            Section('special-notes', text = SPECIAL_NOTES, label = 'Special notes'),
            Section('warnings', text = WARNINGS, label = 'Warnings'),

            program_name        = '',
            section_label_punct = ':',
            after_section_label = '',
            after_section       = '\n',

            program_summary    = '',
            style              = CLI|MAN,
            opt_style          = CLI|MAN,

        ),

    )

    Section
        name  | Short; used symbolically (eg in grammar).
        label | Used in help text

API needs good syntax for retrieving grammar elements:

    g.get(NAME, NAME, ...)          # Get one.
    g.get(NAME, [NAME, ...], ...)   # Get multiple.

    - Support bulk configuration.

    - In user validation code, they need an easy way to get sibling Opt
      information.

Function signature for converters and validators:

    Function  | Arity | Signature
    -------------------------------------------------------
    Converter | 1     | STR            => OBJ/raise
    Validator | 3     | VAL, OPT, OPTS => True/False/raise
    Dispatch  | 3     | VAL, OPT, OPTS => None

--------
classes-and-attributes: Classes and attributes
--------

Parser:

    Attribute        | Note
    --------------------------------------------------------------------------------
    grammar          | Was 'simple_spec'.
    elems            | Was 'opts'.
    --------------------------------------------------------------------------------
    sections         | Defer.
    program          | Defer. The program name, in usage text.
    formatter_config | Defer. FormatterConfig.
    add_help         | Defer.
    --------------------------------------------------------------------------------
    wildcards        | Drop. Was used to support * as a match-anything device.
    --------------------------------------------------------------------------------

Opt:

    Attribute | Note
    --------------------------------------------------------------------------------
    grammar   | Grammar syntax for the Opt. Was 'option_spec'.
    ntimes    | .
    nargs     | .
    nparams   | .
    dest      | Was 'destination'.
    default   | .
    convert   | Callable(s).
    validate  | Callable(s).
    --------------------------------------------------------------------------------
    text      | Defer.
    aliases   | Defer.
    high      | Defer. Was 'tolerant'.
    factory   | Defer. Callable to create default.
    dispatch  | Defer. Callable(s).
    choices   | Defer. Could handle with validate.
    sections  | Defer. Sequence of section names.
    required  | Defer, maybe drop. Same as ntimes=1.
    negaters  | Defer. For flag negatives (to overrule True default)
    hidden    | Defer.
    help      | Defer. For help dispatching. Maybe handle via dispatch attribute.
    --------------------------------------------------------------------------------
    option    | Internal. Not sure of purpose.
    _opt_type | Internal. Holds an OptType.
    arg_names | Internal. Seems related to simple spec parsing.
    --------------------------------------------------------------------------------

Result:

    - Data object returned to end-user by Parser.parse().

    - A mapping-like object with destinations as the attributes.

Target:

    - A data object used during argument parsing to store the
      information ultimately returned as a Result to end user.

    - For the applicable parsing interpretation, a Target contains information
      about all relevant Opt/Pos and values parsed so far.

    Attribute   | Note
    --------------------------------------------------------------------------------
    positionals | List[Pos]
    options     | Dict[Opt]
    values      | Dict[DEST -> VAL]
    --------------------------------------------------------------------------------

TokenType:

    - Internal data object given to a lexer.

    Attribute | Note
    --------------------------------------------------------------------------------
    name      | Name of token.
    rgx       | Regex to match the token.
    emit      | Whether to emit back to parser [default: True].
    --------------------------------------------------------------------------------

RegexLexer:

    - General-purpose regex-based lexer.

    Attribute   | Note
    --------------------------------------------------------------------------------
    text        | The text to be lexed.
    token_types | Sequence of TokenType.
    pos         | Current index of the lexer.
    max_pos     | Last index of the text.
    is_eof      | Becomes True when text exhausted.
    --------------------------------------------------------------------------------

Token:

    - Simple internal data object emitted by a lexer.

    Attribute  | Note
    --------------------------------------------------------------------------------
    token_type | TokenType of the token.
    value      | Corresponding token text.
    --------------------------------------------------------------------------------

GenericParserMixin:

    - Provides parse(), eat(), and error() behaviors.

    Attribute        | Note
    --------------------------------------------------------------------------------
    lexer            | Lexer, supplied by subclass.
    parser_functions | Sequence of token-eating functions, supplied by subclass.
    --------------------------------------------------------------------------------
    current_token    | Managed by the mixin.
    --------------------------------------------------------------------------------

GrammarParser:

    TODO

State:

    - Internal object used during parsing: see arg-parsing-algo .

ArgResult:

    - Internal object used during parsing: see arg-parsing-algo .

--------
deferred-classes: Deferred classes
--------

ParsedOptions
    - Object returned by Parser.parse().
    - Basic form: self.DESTINATION = VALUE.
    - Also behaves like a collection: iterable, dictable, etc.

    args
    parsed_opts
    args_index

ParsedOpt
    - Used by the Parser to store parsing results for an Opt.
    - Each ParsedOpt represents one DESTINATION-VALUE pair.

    destination
    opt
    _values

FormatterConfig
    - Object for the user to configure details about the generation
    - of usage and help text.

    sections
    program_name
    section_label_punct
    after_section_label
    after_section
    program_summary
    style
    opt_style
    alias_style

Section
    - Used to create labeled groups of Opt instances for the purposes
    - of help text generation.

    name
    label
    text
    opts

SimpleSpecParserGenericParser(GenericParserMixin)
    - Used to parse a simple grammar spec given by the user.
    - The parse() method returns a Phrase representing the CLI grammar.

GrammarSpecParser
    - Like SimpleSpecParser, but for the full variant-based grammar.
    # Not implemented yet.

Phrase
    - Object used by Parser to represent CLI grammar and do parsing work.
    - Each Phrase can store subphrases, so the grammar forms a tree.
    - Leaves are Phrase objects corresponding to Opt intances.

    subphrases
    opt

OptToken
    - A data object holding the parsed content of a Token.
    - Lacks constructor; should add.
    - Callers are using these attributes.

    option
    option_spec
    nargs
    opt_type
    arg_names

Enum
    - Used for collections of constants.
    - Should switch to short-con.

    _enum_name
    _members
    _rmembers

EnumMember
    - Used by Enum.
    - The kws dict is used to set as attributes on self.

    enum_name
    name
    value
    **kws

RegexLexerErrorException(Exception)
    pass

OptoPyErrorException(Exception)
    pass

