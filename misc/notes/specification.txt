--------
grammar-syntax: Grammar syntax
--------

Overall structure:

    foo` : PARTIAL_DEFINITION
    bar  : VARIANT_DEFINITION

    Defintions can span multiple lines. Leading colon is required.

        foo` : Blah blah
             : blah blah
             : blah blah
        bar  : Blah

Variant definition syntax:

    Variants:

        foo`             Insert the foo partial into the current partial or variant.

    Grouping and alternatives:

        []               Grouping, optional.
        ()               Grouping.
        foo=[]           Named grouping, optional.
        foo=()           Named grouping.
        |                Alternatives.

    Quantifiers:

        ...              1 or more
        +                1 or more
        *                0 or more
        ?                0 or 1
        {m,n}            Repetition: m through n, inclusive.
        ?                Non-greedy for preceding quantifier.

    Positional arguments:

        <xy>             Positional.
        <xy=a|b>         Positional choices.
        <xy=foo>         Positional variant.

    Options:

        -x               Short.
        --xy             Long.

    Option parameters:

        Unnamed          Named
        --------------------------------------------------
        -p {}            -p {x}         Parameter.
        -p _             .              Parameter.
        -p {=a|b}        -p {x=a|b}     Parameter choices.
        -p {=foo}        -p {x=foo}     Parameter variant.

    Literals:

        'hello world'    Literal: can be used as positional, positional choice,
                         positonal variant, parameter choice, or parameter variant.

    Convenience syntax when configuring a single Opt:

        Positionals      Options
        --------------------------------------------------------
        x x [x]          -f _ [_]       Brackets/braces unneeded
        x=a|b|c          -f a|b         Choices.
        x=a              -f x=a         Variant.

    Whitespace rules:

        - Whitespace required:

            - Quoted literal containing whitespace (no user want this).

            - If a variant ends with an option, whitespace is needed before the
              next variant name (otherwise the names bleed together).

            - To disambiguate names in the convenience syntax for single Opts.

        - Tight-binding required among syntax elements:

            - Option prefix with name.

            - Partial name with back-quote (this could be optional, but
              there is no benefit).

--------
syntax-examples: Syntax examples
--------

blort-maker:

    - This is generally a subcommand-style script, plus various bells and
      whistles to exercise most of the full grammar syntax.

    help`         : [--help] [--syntax]
    general`      : [--verbose] [--log-file {}] help`
    other`        : [--hi] [--bye]

    configure     : help` general` <task=configure> --odin-env {} --od-user {}
    submit        : help` general` <task=submit> -c {} -r {} [--start-job] [--person {name} {age}]
    get           : help` general` <task=get> -j {} [--json [--indent {}] | --b64 | --yaml]
    drop          : help` general` <task=drop> <what=first|last|random> [--print] <n>
    fubb          : help` other` [-a] [-b] <fubb>... (--fast | --slow)
    zzz           : help` other` [-x] [-y] items=(<a> <b> <c> [-z]){2,7}

neck-diagram:

    - This is a non-standard command line program: its grammar consists of one
      or more subcommands with a literal separator between them.

    cmd` :  commands=(
                <cmd=snum>   <snum>             |
                <cmd=fnum>   <fnum>             |
                <cmd=number> <numbering=on|off> |
                <cmd=tuning> <notes>...         |
                <cmd=fret>   <syms>...          |
                <cmd=invert> <syms>...
            )...

    main : cmd` [ '/' cmd` ]...

Sytax example: nab:

    - Another separator-based grammar.
    - But an interesting separator.

    cmd` : '-s' <cmd=chomp>                          |
           '-s' <cmd=findall> <rgx>                  |
           '-s' <cmd=grep> <rgx> [-i] [-v] [-s]      |
           '-s' <cmd=range> <start> <stop> [<step>]  |
           '-s' <cmd=run> <code> [-g {}] [-a]

    main : [--help] commands=cmd`...

--------
single-opt-convenience-syntax: Convenience syntax for single Opts
--------

    Convenience syntax when configuring a single Opt:

        x x [x]     Positionals can drop <> brackets.
        x=a|b|c     Ditto, with choices.
        -f _ [_]    Parameters can drop {} brackets.
        -f a b      Ditto, with named parameters.

        - Some examples using full syntax:

            Opt('<what>')
            Opt('<what=first|last|random>')
            Opt('<x> <x> [<x>]')
            Opt('--foo')
            Opt('--foo {} {} [{}]')
            Opt('--foo {a} {b} [{c}]')

        - Same examples using convenience syntax, which drops the explicit
          brackets for positionals and parameters.

            Opt('what')
            Opt('what=first|last|random')
            Opt('x x [x]')
            Opt('--foo')
            Opt('--foo _ _ [_]')
            Opt('--foo a b [c]')

--------
terminology: Terminology
--------

Users:

    - Library: the optopus code base.
    - Library user (or just user): a developer using optopus.
    - End user: a user running a program that uses optopus.

Command line argument types:

    - Arguments:
        - The raw strings directly from the command line.

    - Positionals:
        - The typical non-option argument.

    - Options: arguments with an option prefix.

        - Long prefix.
        - Short prefix.

        - Option (parameter option)
        - Flag


    - Parameters:
        - Arguments for an option.

    - Positional or parameter variant:
        - Mechanism to define a special grammar when a
          positional or parameter takes a specific value.

Help text sections:

    - Terminology in this project:
        - Usage text: conveys the command-line grammar.
        - Options text: documents the options and positional arguments, perhaps in groups.
        - Custom sections.

    - Command line style:
        - Usage.
        - Positional arguments.
        - Options and/or option groups.
        - Custom sections.

    - Man-page style:

        - NAME
        - SYNOPSIS
        - DESCRIPTION
        - OPTIONS
        - Custom sections.

Destination assignment:

    - Controls how the parsed data elements are stored and named.

--------
old-api-examples: Old API examples
--------

NEEDS EDITING PASS

When working on the Parser API, also see odin-client-via-api. It's
somewhat out of date but might have useful ideas.

####
# Parser.
####

p = Parser()

p.parse(args = None)
p.parse_known(args = None)
p.help_text(section = None)
p.error_text()
p.warn(msg)
p.error(code = None, msg = None))
p.exit(code = None, msg = None)

####
# Opts.
####

o = Opt(
    option     = '--job-id',            # Or string-spec with option, aliases, and arg_name.
    aliases    = ['-j', '-J', '--jid'], # Or just one string.
    n_args     = 1,
    repeatable = False,                 # If true, append values.
    choices    = ('A', 'B', 'C', 'D'),
    required   = False,
    tolerant   = False,                 # Setting option makes grammar fully tolerant.
    high       = False,                 # A high-precedence option (eg --help).
    greedy     = True,                  # Affects options arg consumption.
)

####
# Examples.
####

p = Parser(
    # Via simple Opt.
    Opt('--since TERM', type = int, default = 123),
    Opt('--limit N', type = int, default = 0),
    Opt('--rebuild'),
    Opt('--experiment EXP'),
    Opt('--stats'),
    Opt('--month M'),
    Opt('--search TERM', repeatable = True),
    Opt('--get ITEM'),

    # Via full Opts.
    Opt(
        'task',
        choices = 'configure submit upload start get stop download find'.split(),
        desc    = 'The odin-client task to run',
    ),

    # Via dict.
    dict(
        option  = '--odin-env ENV',
        groups  = 'general',
        default = 'dev',
        desc    = "Odin environment ('production' for most users).",
    ),

    parsing_config = {
        allow_abbrev = True,
        opt_prefix_rgx = ...,
    },

    formatter_config = {
        program_name = '...',
        etc ...
    },

)

# All help-text section, in order.
p.help_text()

# Specific help-text sections, in the requested order.
p.help_text('usage')
p.help_text('section-foo')
p.help_text('section-foo', 'section-bar')

####
# SimpleSpec.
####

VERDICT: dropping this concept.

For example:

    --verbose --type A <x> <y> -h -g

    spec = '-n NAME --foo --bar B1 B2 <x> <y>'
    p = parser(simple = spec)


    expr        = (longoption | shortoption | posarg)+

    longoption  = longopt optarg*
    shortoption = shortopt optarg*
    posarg      = "<" char+ ">"

    longopt     = "--" char+
    shortopt    = "-" char
    optarg      = [A-Z_\-\d]+
    char        = [\w\-]

Elements:

    short opt  | -h
    long opt   | --type
    opt arg    | A
    positional | <x>


# Creating a Grammar via the API

    general_opts = Partial(
        'general',
        Opt('--verbose'),
        Opt('--log-file {}'),
    )

    other_opts = Partial(
        'other',
        Opt('--hi'),
        Opt('--bye'),
    )

    task_opt = Opt(
        'task',
        choices = ('configure', 'submit', 'get', 'drop'),
    )

    general_zone = Zone(general_opts)

    variants = [
        Variant(
            'configure',
            general_zone,
            Zone(
                Choice(task_opt, value = 'configure', anchor = True),
                Opt('--odin-env {}', required = True),
                Opt('--od-user {}', required = True),
            ),
        ),
        Variant(
            'submit',
            general_zone,
            Zone(
                Choice(task_opt, value = 'submit', anchor = True),
                Opt('-c {}', required = True),
                Opt('-r {}', required = True),
                Opt('--start-job'),
                Opt('--person {name} {age}'),
            ),
        ),
        Variant(
            'get',
            general_zone,
            Zone(
                Choice(task_opt, value = 'get', anchor = True),
                Opt('-j {}', required = True),
                Alternatives(
                    Group(
                        Opt('--json', required = True),
                        Opt('--indent {}'),
                    ),
                    Opt('--b64'),
                    Opt('--yaml'),
                    required = False,
                ),
            ),
        ),
        Variant(
            'drop',
            general_zone,
            Zone(
                Choice(task_opt, value = 'drop', anchor = True),
                Opt('what', choices = ('first', 'last', 'random'), required = True),
                Opt('--print'),
                Opt('n'),
            ),
        ),
        Variant(
            'fubb',
            Opt('-a'),
            Opt('-b'),
            other_opts,
            Opt('fubb', nargs = (1, None)),
            Alternatives(
                Opt('--fast'),
                Opt('--slow'),
            ),
        ),
        Variant(
            'zzz',
            Opt('-x'),
            Opt('-y'),
            other_opts,
            Group(
                Opt('a'),
                Opt('b'),
                Opt('c'),
                Opt('-z'),
                ntimes = (2, 7),
            ),
        ),
        Variant(
            'help',
            Opt('--help', high = True),
        ),
    ]

API: FormatterConfig example:

    p = Parser(

        Opt(
            '--blort',
            text = '',
            sections = ['foo', 'bar'],             # Can be str or list/tuple/set.
        ),

        formatter_config = FormatterConfig(

            # Either Section or iterable.
            # Default label: "Foo options"
            Section('usage', label = '...'),
            Section('foo'),
            Section('bar'),
            Section('short-opts'),
            Section('special-notes', text = SPECIAL_NOTES, label = 'Special notes'),
            Section('warnings', text = WARNINGS, label = 'Warnings'),

            program_name        = '',
            section_label_punct = ':',
            after_section_label = '',
            after_section       = '\n',

            program_summary    = '',
            style              = CLI|MAN,
            opt_style          = CLI|MAN,

        ),

    )

    Section
        name  | Short; used symbolically (eg in grammar).
        label | Used in help text

API needs good syntax for retrieving grammar elements:

    g.get(NAME, NAME, ...)          # Get one.
    g.get(NAME, [NAME, ...], ...)   # Get multiple.

    - Support bulk configuration.

    - In user validation code, they need an easy way to get sibling Opt
      information.

Function signature for converters and validators:

    Function  | Arity | Signature
    -------------------------------------------------------
    Converter | 1     | STR            => OBJ/raise
    Validator | 3     | VAL, OPT, OPTS => True/False/raise
    Dispatch  | 3     | VAL, OPT, OPTS => None

--------
classes-and-attributes: Classes and attributes
--------

Parser:

    Attribute        | Note
    --------------------------------------------------------------------------------
    grammar          | Was 'simple_spec'.
    elems            | Was 'opts'.
    --------------------------------------------------------------------------------
    sections         | Defer.
    program          | Defer. The program name, in usage text.
    formatter_config | Defer. FormatterConfig.
    add_help         | Defer.
    --------------------------------------------------------------------------------
    wildcards        | Drop. Was used to support * as a match-anything device.
    --------------------------------------------------------------------------------

Opt:

    Attribute | Note
    --------------------------------------------------------------------------------
    grammar   | Grammar syntax for the Opt. Was 'option_spec'.
    ntimes    | .
    nargs     | .
    nparams   | .
    dest      | Was 'destination'.
    default   | .
    convert   | Callable(s).
    validate  | Callable(s).
    --------------------------------------------------------------------------------
    text      | Defer.
    aliases   | Defer.
    high      | Defer. Was 'tolerant'.
    factory   | Defer. Callable to create default.
    dispatch  | Defer. Callable(s).
    choices   | Defer. Could handle with validate.
    sections  | Defer. Sequence of section names.
    required  | Defer, maybe drop. Same as ntimes=1.
    negaters  | Defer. For flag negatives (to overrule True default)
    hidden    | Defer.
    help      | Defer. For help dispatching. Maybe handle via dispatch attribute.
    --------------------------------------------------------------------------------
    option    | Internal. Not sure of purpose.
    _opt_type | Internal. Holds an OptType.
    arg_names | Internal. Seems related to simple spec parsing.
    --------------------------------------------------------------------------------

Result:

    - Data object returned to end-user by Parser.parse().

    - A mapping-like object with destinations as the attributes.

Target:

    - A data object used during argument parsing to store the
      information ultimately returned as a Result to end user.

    - For the applicable parsing interpretation, a Target contains information
      about all relevant Opt/Pos and values parsed so far.

    Attribute   | Note
    --------------------------------------------------------------------------------
    positionals | List[Pos]
    options     | Dict[Opt]
    values      | Dict[DEST -> VAL]
    --------------------------------------------------------------------------------

TokenType:

    - Internal data object given to a lexer.

    Attribute | Note
    --------------------------------------------------------------------------------
    name      | Name of token.
    rgx       | Regex to match the token.
    emit      | Whether to emit back to parser [default: True].
    --------------------------------------------------------------------------------

RegexLexer:

    - General-purpose regex-based lexer.

    Attribute   | Note
    --------------------------------------------------------------------------------
    text        | The text to be lexed.
    token_types | Sequence of TokenType.
    pos         | Current index of the lexer.
    max_pos     | Last index of the text.
    is_eof      | Becomes True when text exhausted.
    --------------------------------------------------------------------------------

Token:

    - Simple internal data object emitted by a lexer.

    Attribute  | Note
    --------------------------------------------------------------------------------
    token_type | TokenType of the token.
    value      | Corresponding token text.
    --------------------------------------------------------------------------------

GenericParserMixin:

    - Provides parse(), eat(), and error() behaviors.

    Attribute        | Note
    --------------------------------------------------------------------------------
    lexer            | Lexer, supplied by subclass.
    parser_functions | Sequence of token-eating functions, supplied by subclass.
    --------------------------------------------------------------------------------
    current_token    | Managed by the mixin.
    --------------------------------------------------------------------------------

GrammarParser:

    - TODO

State:

    - Internal object used during parsing: see arg-parsing-algo .

ArgResult:

    - Internal object used during parsing: see arg-parsing-algo .

--------
deferred-classes: Deferred classes
--------

ParsedOptions
    - Object returned by Parser.parse().
    - Basic form: self.DESTINATION = VALUE.
    - Also behaves like a collection: iterable, dictable, etc.

    args
    parsed_opts
    args_index

ParsedOpt
    - Used by the Parser to store parsing results for an Opt.
    - Each ParsedOpt represents one DESTINATION-VALUE pair.

    destination
    opt
    _values

FormatterConfig
    - Object for the user to configure details about the generation
    - of usage and help text.

    sections
    program_name
    section_label_punct
    after_section_label
    after_section
    program_summary
    style
    opt_style
    alias_style

Section
    - Used to create labeled groups of Opt instances for the purposes
    - of help text generation.

    name
    label
    text
    opts

SimpleSpecParserGenericParser(GenericParserMixin)
    - Used to parse a simple grammar spec given by the user.
    - The parse() method returns a Phrase representing the CLI grammar.

GrammarSpecParser
    - Like SimpleSpecParser, but for the full variant-based grammar.
    # Not implemented yet.

Phrase
    - Object used by Parser to represent CLI grammar and do parsing work.
    - Each Phrase can store subphrases, so the grammar forms a tree.
    - Leaves are Phrase objects corresponding to Opt intances.

    subphrases
    opt

OptToken
    - A data object holding the parsed content of a Token.
    - Lacks constructor; should add.
    - Callers are using these attributes.

    option
    option_spec
    nargs
    opt_type
    arg_names

Enum
    - Used for collections of constants.
    - Should switch to short-con.

    _enum_name
    _members
    _rmembers

EnumMember
    - Used by Enum.
    - The kws dict is used to set as attributes on self.

    enum_name
    name
    value
    **kws

RegexLexerErrorException(Exception)
    pass

OptoPyErrorException(Exception)
    pass

