--------
grammar-syntax: Grammar syntax
--------

Overall structure:

    foo` : PARTIAL_DEFINITION
    bar  : VARIANT_DEFINITION

Variant definition syntax:

    Variants:

        foo`        Insert the foo partial into the current partial or variant.

    Grouping and alternatives:

        []          Grouping, optional.
        ()          Grouping.
        |           Alternatives.

    Quantifiers:

        ...         1 or more
        {m,n}       Repetition: m through n, inclusive.
        ?           Non-greedy quantifier.

    Positional arguments:

        <xy>        Positional.
        <xy=foo>    Positional variant.
        'bar'       Literal (eg, for separators).

    Options:

        -x          Short.
        --xy        Long.

    Option parameters:

        -p {}       Parameter.
        -p {x}      Parameter, named.
        -p {=foo}   Parameter variant.
        -p {x=foo}  Parameter variant, named.

    General destination assignment:

        foo=(...)   In returned data, organize the data from ... under
                    the foo attribute. Most applicable for variants/groups.

    Convenience syntax when configuring a single Opt:

        x x [x]     Positionals can drop <> brackets.
        x=a|b|c     Ditto, with choices.
        -f _ [_]    Parameters can drop {} brackets.
        -f a b      Ditto, with named parameters.

--------
syntax-examples: Syntax examples
--------

blort-maker:

    - This is generally a subcommand-style script, plus various bells and
      whistles to exercise most of the full grammar syntax.

    help`         : [--help] [--syntax]
    general`      : [--verbose] [--log-file {}] help`
    other`        : [--hi] [--bye]

    configure     : help` general` <task=configure> --odin-env {} --od-user {}
    submit        : help` general` <task=submit> -c {} -r {} [--start-job] [--person {name} {age}]
    get           : help` general` <task=get> -j {} [--json [--indent {}] | --b64 | --yaml]
    drop          : help` general` <task=drop> <what=first|last|random> [--print] <n>
    fubb          : help` other` [-a] [-b] <fubb>... (--fast | --slow)
    zzz           : help` other` [-x] [-y] items=(<a> <b> <c> [-z]){2,7}

neck-diagram:

    - This is a non-standard command line program: its grammar consists of one
      or more subcommands with a literal separator between them.

    cmd` :  commands=(
                <cmd=snum>   <snum>             |
                <cmd=fnum>   <fnum>             |
                <cmd=number> <numbering=on|off> |
                <cmd=tuning> <notes>...         |
                <cmd=fret>   <syms>...          |
                <cmd=invert> <syms>...
            )...

    main : cmd` [ '/' cmd` ]...

Sytax example: nab:

    - Another separator-based grammar.
    - But an interesting separator.

    cmd` :  (
                '-s' <cmd=chomp>                          |
                '-s' <cmd=findall> <rgx>                  |
                '-s' <cmd=grep> <rgx> [-i] [-v] [-s]      |
                '-s' <cmd=range> <start> <stop> [<step>]  |
                '-s' <cmd=run> <code> [-g {}] [-a]
            )

    main : [--help] commands=(cmd`...)

--------
single-opt-convenience-syntax: Convenience syntax for single Opts
--------

    Convenience syntax when configuring a single Opt:

        x x [x]     Positionals can drop <> brackets.
        x=a|b|c     Ditto, with choices.
        -f _ [_]    Parameters can drop {} brackets.
        -f a b      Ditto, with named parameters.

        - Some examples using full syntax:

            Opt('<what>')
            Opt('<what=first|last|random>')
            Opt('<x> <x> [<x>]')
            Opt('--foo')
            Opt('--foo {} {} [{}]')
            Opt('--foo {a} {b} [{c}]')

        - Same examples using convenience syntax, which drops the explicit
          brackets for positionals and parameters.

            Opt('what')
            Opt('what=first|last|random')
            Opt('x x [x]')
            Opt('--foo')
            Opt('--foo _ _ [_]')
            Opt('--foo a b [c]')

--------
terminology: Terminology
--------

Users:

    - Library: the opto-py code base.
    - Library user (or just user): a developer using opto-py.
    - End user: a user running a program that uses opto-py.

Command line argument types:

    - Arguments:
        - The raw strings directly from the command line.

    - Positionals:
        - The typical non-option argument.

    - Options: arguments with an option prefix.

        - Long
        - Short

        - Option (parameter option)
        - Flag

    - Parameters:
        - Arguments for an option.

    - Positional or parameter variant:
        - Mechanism to define a special grammar when a
          positional or parameter takes a specific value.

Help text sections:

    - Terminology in this project:
        - Usage text: conveys the command-line grammar.
        - Options text: documents the options and positional arguments, perhaps in groups.
        - Custom sections.

    - Command line style:
        - Usage.
        - Positional arguments.
        - Options and/or option groups.
        - Custom sections.

    - Man-page style:

        - NAME
        - SYNOPSIS
        - DESCRIPTION
        - OPTIONS
        - Custom sections.

Destination assignment:

    - Controls how the parsed data elements are stored and named.

--------
old-api-examples: Old API examples
--------

NEEDS EDITING PASS

When working on the Parser API, also see odin-client-via-api. It's
somewhat out of date but might have useful ideas.

####
# Parser.
####

p = Parser()

p.parse(args = None)
p.parse_known(args = None)
p.help_text(section = None)
p.error_text()
p.warn(msg)
p.error(code = None, msg = None))
p.exit(code = None, msg = None)

####
# Opts.
####

o = Opt(
    option     = '--job-id',            # Or string-spec with option, aliases, and arg_name.
    aliases    = ['-j', '-J', '--jid'], # Or just one string.
    n_args     = 1,
    repeatable = False,                 # If true, append values.
    choices    = ('A', 'B', 'C', 'D'),
    required   = False,
    tolerant   = False,                 # Setting option makes grammar fully tolerant.
    high       = False,                 # A high-precedence option (eg --help).
    greedy     = True,                  # Affects options arg consumption.
)

####
# Examples.
####

p = Parser(
    # Via simple Opt.
    Opt('--since TERM', type = int, default = 123),
    Opt('--limit N', type = int, default = 0),
    Opt('--rebuild'),
    Opt('--experiment EXP'),
    Opt('--stats'),
    Opt('--month M'),
    Opt('--search TERM', repeatable = True),
    Opt('--get ITEM'),

    # Via full Opts.
    Opt(
        'task',
        choices = 'configure submit upload start get stop download find'.split(),
        desc    = 'The odin-client task to run',
    ),

    # Via dict.
    dict(
        option  = '--odin-env ENV',
        groups  = 'general',
        default = 'dev',
        desc    = "Odin environment ('production' for most users).",
    ),

    parsing_config = {
        allow_abbrev = True,
        opt_prefix_rgx = ...,
    },

    formatter_config = {
        program_name = '...',
        etc ...
    },

)

# All help-text section, in order.
p.help_text()

# Specific help-text sections, in the requested order.
p.help_text('usage')
p.help_text('section-foo')
p.help_text('section-foo', 'section-bar')

####
# SimpleSpec.
####

VERDICT: dropping this concept.

For example:

    --verbose --type A <x> <y> -h -g

    spec = '-n NAME --foo --bar B1 B2 <x> <y>'
    p = parser(simple = spec)


    expr        = (longoption | shortoption | posarg)+

    longoption  = longopt optarg*
    shortoption = shortopt optarg*
    posarg      = "<" char+ ">"

    longopt     = "--" char+
    shortopt    = "-" char
    optarg      = [A-Z_\-\d]+
    char        = [\w\-]

Elements:

    short opt  | -h
    long opt   | --type
    opt arg    | A
    positional | <x>


# Creating a Grammar via the API

    general_opts = Partial(
        'general',
        Opt('--verbose'),
        Opt('--log-file {}'),
    )

    other_opts = Partial(
        'other',
        Opt('--hi'),
        Opt('--bye'),
    )

    task_opt = Opt(
        'task',
        choices = ('configure', 'submit', 'get', 'drop'),
    )

    general_zone = Zone(general_opts)

    variants = [
        Variant(
            'configure',
            general_zone,
            Zone(
                Choice(task_opt, value = 'configure', anchor = True),
                Opt('--odin-env {}', required = True),
                Opt('--od-user {}', required = True),
            ),
        ),
        Variant(
            'submit',
            general_zone,
            Zone(
                Choice(task_opt, value = 'submit', anchor = True),
                Opt('-c {}', required = True),
                Opt('-r {}', required = True),
                Opt('--start-job'),
                Opt('--person {name} {age}'),
            ),
        ),
        Variant(
            'get',
            general_zone,
            Zone(
                Choice(task_opt, value = 'get', anchor = True),
                Opt('-j {}', required = True),
                Alternatives(
                    Group(
                        Opt('--json', required = True),
                        Opt('--indent {}'),
                    ),
                    Opt('--b64'),
                    Opt('--yaml'),
                    required = False,
                ),
            ),
        ),
        Variant(
            'drop',
            general_zone,
            Zone(
                Choice(task_opt, value = 'drop', anchor = True),
                Opt('what', choices = ('first', 'last', 'random'), required = True),
                Opt('--print'),
                Opt('n'),
            ),
        ),
        Variant(
            'fubb',
            Opt('-a'),
            Opt('-b'),
            other_opts,
            Opt('fubb', nargs = (1, None)),
            Alternatives(
                Opt('--fast'),
                Opt('--slow'),
            ),
        ),
        Variant(
            'zzz',
            Opt('-x'),
            Opt('-y'),
            other_opts,
            Group(
                Opt('a'),
                Opt('b'),
                Opt('c'),
                Opt('-z'),
                ntimes = (2, 7),
            ),
        ),
        Variant(
            'help',
            Opt('--help', high = True),
        ),
    ]

API: FormatterConfig example:

    p = Parser(

        Opt(
            '--blort',
            text = '',
            sections = ['foo', 'bar'],             # Can be str or list/tuple/set.
        ),

        formatter_config = FormatterConfig(

            # Either Section or iterable.
            # Default label: "Foo options"
            Section('usage', label = '...'),
            Section('foo'),
            Section('bar'),
            Section('short-opts'),
            Section('special-notes', text = SPECIAL_NOTES, label = 'Special notes'),
            Section('warnings', text = WARNINGS, label = 'Warnings'),

            program_name        = '',
            section_label_punct = ':',
            after_section_label = '',
            after_section       = '\n',

            program_summary    = '',
            style              = CLI|MAN,
            opt_style          = CLI|MAN,

        ),

    )

    Section
        name  | Short; used symbolically (eg in grammar).
        label | Used in help text

API needs good syntax for retrieving grammar elements:

    g.get(NAME, NAME, ...)          # Get one.
    g.get(NAME, [NAME, ...], ...)   # Get multiple.

    - Support bulk configuration.

    - In user validation code, they need an easy way to get sibling Opt
      information.

Function signature for converters and validators:

    Function  | Arity | Signature
    -------------------------------------------------------
    Converter | 1     | STR            => OBJ/raise
    Validator | 3     | VAL, OPT, OPTS => True/False/raise
    Dispatch  | 3     | VAL, OPT, OPTS => None

--------
classes-and-attributes: Classes and attributes
--------

Parser
    # Command line option and argument parser.

    opts
    simple_spec
    wildcards
    sections
    formatter_config
    program
    add_help

Opt

    - Used to configure an option or positional.

    Attribute | Note
    --------------------------------------------------------------------------------
    grammar   | Grammar syntax for the Opt. Was 'option_spec'.
    ntimes    | .
    nargs     | .
    nparams   | .
    dest      | Was 'destination'.
    default   | .
    convert   | Callable(s).
    validate  | Callable(s).
    --------------------------------------------------------------------------------
    text      | Defer.
    aliases   | Defer.
    high      | Defer. Was 'tolerant'.
    factory   | Defer. Callable to create default.
    dispatch  | Defer. Callable(s).
    choices   | Defer. Could handle with validate.
    sections  | Defer. Sequence of section names.
    required  | Defer, maybe drop. Same as ntimes=1.
    negaters  | Defer. For flag negatives (to overrule True default)
    hidden    | Defer.
    help      | Defer. For help dispatching. Maybe handle via dispatch attribute.
    --------------------------------------------------------------------------------
    option    | Internal. Not sure of purpose.
    _opt_type | Internal. Holds an OptType.
    arg_names | Internal. Seems related to simple spec parsing.
    --------------------------------------------------------------------------------

ParsedOptions
    # Object returned by Parser.parse().
    # Basic form: self.DESTINATION = VALUE.
    # Also behaves like a collection: iterable, dictable, etc.

    args
    parsed_opts
    args_index

ParsedOpt
    # Used by the Parser to store parsing results for an Opt.
    # Each ParsedOpt represents one DESTINATION-VALUE pair.

    destination
    opt
    _values

FormatterConfig
    # Object for the user to configure details about the generation
    # of usage and help text.

    sections
    program_name
    section_label_punct
    after_section_label
    after_section
    program_summary
    style
    opt_style
    alias_style

Section
    # Used to create labeled groups of Opt instances for the purposes
    # of help text generation.

    name
    label
    text
    opts

GenericParser
    # A general-purpose parser meant to be sub-classed.
    # The subclass provides a lexer and parsing functions.

    lexer
    parser_functions
    current_token

SimpleSpecParserGenericParser(GenericParser)
    # Used to parse a simple grammar spec given by the user.
    # The parse() method returns a Phrase representing the CLI grammar.

GrammarSpecParser
    # Like SimpleSpecParser, but for the full variant-based grammar.
    # Not implemented yet.

Phrase
    # Object used by Parser to represent CLI grammar and do parsing work.
    # Each Phrase can store subphrases, so the grammar forms a tree.
    # Leaves are Phrase objects corresponding to Opt intances.

    subphrases
    opt

RegexLexer
    # General purpose lexer for use by SimpleSpecParser and GrammarSpecParser.

    text
    token_types
    pos
    max_pos
    is_eof

Token
    # Simple data object emitted by the RegexLexer.

    token_type
    value

OptToken
    # A data object holding the parsed content of a Token.
    # Lacks constructor; should add.
    # Callers are using these attributes.

    option
    option_spec
    nargs
    opt_type
    arg_names

Enum
    # Used for collections of constants.
    # Should switch to short-con.

    _enum_name
    _members
    _rmembers

EnumMember
    # Used by Enum.

    enum_name
    name
    value
    **kws    # Set as attributes on self

RegexLexerErrorException(Exception)
    pass

OptoPyErrorException(Exception)
    pass

