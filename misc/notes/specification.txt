--------
grammar-syntax: Grammar syntax
--------

Overall structure:

    foo` : PARTIAL_DEFINITION
    bar  : VARIANT_DEFINITION

    Defintions can span multiple lines. Leading colon is required.

        foo` : Blah blah
             : blah blah
             : blah blah
        bar  : Blah

Variant definition syntax:

    Variants:

        foo`             Insert the foo partial into the current partial or variant.

    Grouping and alternatives:

        []               Grouping, optional.
        ()               Grouping.
        foo=[]           Named grouping, optional.
        foo=()           Named grouping.
        |                Alternatives.

    Quantifiers:

        ...              1 or more
        +                1 or more
        *                0 or more
        ?                0 or 1
        {m,n}            Repetition: m through n, inclusive.
        ?                Non-greedy for preceding quantifier.

    Positional arguments:

        <xy>             Positional.
        <xy=a|b>         Positional choices.
        <xy=foo>         Positional variant.

    Options:

        -x               Short.
        --xy             Long.

    Option parameters:

        Unnamed          Named
        --------------------------------------------------
        -p {}            -p {x}         Parameter.
        -p _             .              Parameter.
        -p {=a|b}        -p {x=a|b}     Parameter choices.
        -p {=foo}        -p {x=foo}     Parameter variant.

    Literals:

        'hello world'    Literal: can be used as positional, positional choice,
                         positonal variant, parameter choice, or parameter variant.

    Convenience syntax when configuring a single Opt:

        Positionals      Options
        --------------------------------------------------------
        x x [x]          -f _ [_]       Brackets/braces unneeded
        x=a|b|c          -f a|b         Choices.

    Whitespace rules:

        - Whitespace required:

            - Quoted literal containing whitespace (no user want this).

            - If a variant ends with an option, whitespace is needed before the
              next variant name (otherwise the names bleed together).

            - To disambiguate names in the convenience syntax for single Opts.

        - Tight-binding required among syntax elements:

            - Option prefix with name.

            - Partial name with back-quote (this could be optional, but
              there is no benefit).

--------
syntax-examples: Syntax examples
--------

blort-maker:

    - This is generally a subcommand-style script, plus various bells and
      whistles to exercise most of the full grammar syntax.

    help`         : [--help] [--syntax]
    general`      : [--verbose] [--log-file {}] help`
    other`        : [--hi] [--bye]

    configure     : help` general` <task=configure> --odin-env {} --od-user {}
    submit        : help` general` <task=submit> -c {} -r {} [--start-job] [--person {name} {age}]
    get           : help` general` <task=get> -j {} [--json [--indent {}] | --b64 | --yaml]
    drop          : help` general` <task=drop> <what=first|last|random> [--print] <n>
    fubb          : help` other` [-a] [-b] <fubb>... (--fast | --slow)
    zzz           : help` other` [-x] [-y] items=(<a> <b> <c> [-z]){2,7}

neck-diagram:

    - This is a non-standard command line program: its grammar consists of one
      or more subcommands with a literal separator between them.

    cmd` :  commands=(
                <cmd=snum>   <snum>             |
                <cmd=fnum>   <fnum>             |
                <cmd=number> <numbering=on|off> |
                <cmd=tuning> <notes>...         |
                <cmd=fret>   <syms>...          |
                <cmd=invert> <syms>...
            )...

    main : cmd` [ '/' cmd` ]...

Sytax example: nab:

    - Another separator-based grammar.
    - But an interesting separator.

    cmd` : '-s' <cmd=chomp>                          |
           '-s' <cmd=findall> <rgx>                  |
           '-s' <cmd=grep> <rgx> [-i] [-v] [-s]      |
           '-s' <cmd=range> <start> <stop> [<step>]  |
           '-s' <cmd=run> <code> [-g {}] [-a]

    main : [--help] commands=cmd`...

--------
single-opt-convenience-syntax: Convenience syntax for single Opts
--------

    Convenience syntax when configuring a single Opt:

        x x [x]     Positionals can drop <> brackets.
        x=a|b|c     Ditto, with choices.
        -f _ [_]    Parameters can drop {} brackets.
        -f a b      Ditto, with named parameters.

        - Some examples using full syntax:

            Opt('<what>')
            Opt('<what=first|last|random>')
            Opt('<x> <x> [<x>]')
            Opt('--foo')
            Opt('--foo {} {} [{}]')
            Opt('--foo {a} {b} [{c}]')

        - Same examples using convenience syntax, which drops the explicit
          brackets for positionals and parameters.

            Opt('what')
            Opt('what=first|last|random')
            Opt('x x [x]')
            Opt('--foo')
            Opt('--foo _ _ [_]')
            Opt('--foo a b [c]')

--------
terminology: Terminology
--------

Users:

    - Library: the optopus code base.
    - Library user (or just user): a developer using optopus.
    - End user: a user running a program that uses optopus.

Command line argument types:

    - Arguments:
        - The raw strings directly from the command line.

    - Positionals:
        - The typical non-option argument.

    - Options: arguments with an option prefix.

        - Long prefix.
        - Short prefix.

        - Option (parameter option)
        - Flag


    - Parameters:
        - Arguments for an option.

    - Positional or parameter variant:
        - Mechanism to define a special grammar when a
          positional or parameter takes a specific value.

Help text sections:

    - Terminology in this project:
        - Usage text: conveys the command-line grammar.
        - Options text: documents the options and positional arguments, perhaps in groups.
        - Custom sections.

    - Command line style:
        - Usage.
        - Positional arguments.
        - Options and/or option groups.
        - Custom sections.

    - Man-page style:

        - NAME
        - SYNOPSIS
        - DESCRIPTION
        - OPTIONS
        - Custom sections.

Destination assignment:

    - Controls how the parsed data elements are stored and named.

--------
classes-and-attributes: Classes and attributes
--------

Overview:

    User-facing entities:

        Parser
        Section
        Grammar
        Variant
        Group
        Opt
        Result

        Relationships:

            Parser
                sections      = List[Section]      # 0+
                grammar       = Grammar            # 0 or 1
                    variants  = List[Variant]      # 0+
                        elems = List[Group or Opt] # 0+

                parse(ARGS) -> Result

            Group:
                elems = List[Group or Opt] # 0+

    Objects used during grammar parsing:

        GrammarParser      | Parses a spec, returns Grammar.
        RegexLexer         | Lexer used by GrammarParser.
        TokType            | Token types given to lexer.
        Token              | Emitted by lexer.
        ParseElem          | Emitted by parser functions. Later assembled into Grammar.

    Objects used during argument parsing:

        State
        ArgResult
        Target

    Entities used only for notation:

        PartialUsage      | Group
        Positional        | Opt
        PositionalVariant | Opt
        ParameterVariant  | Opt

Parser:

    - Class will likely have various getters or query functionality to make it
      easy to configure specific grammar elements. Users should not have to
      manually navigate the Grammar hierarchy very often.

    Attribute | Note
    --------------------------------------------------------------------------------
    spec      | Was 'simple_spec'.
    grammar   | Grammar. Was 'opts'.
    --------------------------------------------------------------------------------
    auto      | Defer. True by default: exit with error on failed parse().
    sections  | Defer.
    format    | Defer. Data object to namepsace formatting attributes. Was 'formatter_config'.
    helpful   | Defer.
    mode      | Defer. For special modes (parse-known, best-effort, flags, keyvals, greedy).
    --------------------------------------------------------------------------------
    program   | Drop: move under format.
    wildcards | Drop. Was used to support * as a match-anything device.
    --------------------------------------------------------------------------------

    API:

        Parser(spec = None, grammar = None, ...)

            - The spec/grammar arguments are mutex and optional.
            - Other arguments are defferred.

        parse(args = None, mode = ...) -> Result or raise

            - Parser can have a mode.
            - And parse() can temporarily use a different mode.

        # Obtaining help text or text for the error from most recent parse():

            help_text(section...)
            error_text
            exception

        # Actions like printing or exiting.

            warn(msg)
            help(section...)
            error(msg = None, code = 1)
            exit(msg = None, code = 0)

Section

    - Used to create labeled groups of Opt for help text purposes.
    - Each variant has a corresponding section with the same name.

    Attribute | Note
    --------------------------------------------------------------------------------
    name      | Short symbolic name used in API.
    label     | Used in help text.
    opts      | Opts belonging to the section.
    text      | Hand-crafted help text.
    --------------------------------------------------------------------------------

Grammar:

    Attribute | Note
    --------------------------------------------------------------------------------
    variants  | List[Variant]
    --------------------------------------------------------------------------------

    API:

        TODO

Variant:

    Attribute | Note
    --------------------------------------------------------------------------------
    elems     | List[Group or Opt]
    --------------------------------------------------------------------------------

Group:

    Attribute | Note
    --------------------------------------------------------------------------------
    elems     | List[Group or Opt]
    --------------------------------------------------------------------------------

Opt:

    Attribute | Note
    --------------------------------------------------------------------------------
    spec      | Was 'option_spec'.
    grammar   | Grammar.
    ntimes    | .
    nargs     | .
    nparams   | .
    dest      | Was 'destination'.
    default   | .
    convert   | Callable(s).
    validate  | Callable(s).
    value     | None (typical) or the variant value.
    --------------------------------------------------------------------------------
    text      | Defer.
    choices   | Defer.
    aliases   | Defer.
    high      | Defer. Was 'tolerant'.
    factory   | Defer. Callable to create default.
    dispatch  | Defer. Callable(s). Maybe 'actions'.
    sections  | Defer. Sequence of section names.
    required  | Defer, maybe drop. Same as ntimes=1.
    negaters  | Defer. For flag negatives (to overrule True default)
    hide      | Defer. False (visible), True (hidden), or sequence of where/what to hide
    case      | Defer. Case-sensitive if True.
    help      | Defer. For help dispatching. Maybe handle via dispatch attribute.
    anchor    | Defer. bool
    metavar   | Defer. But need a better name.
    --------------------------------------------------------------------------------
    option    | Internal. Not sure of purpose.
    _opt_type | Internal. Holds an OptType.
    arg_names | Internal. Seems related to simple spec parsing.
    --------------------------------------------------------------------------------

Result:

    - Data object returned to end-user by Parser.parse().

    - An iterable mapping-like object with destinations as the attributes.

GrammarParser:

    Attribute | Note
    --------------------------------------------------------------------------------
    lexer     | Lexer.
    handlers  | Sequence of token-stream handlers. Was 'parser_functions'.
    curr      | Was 'current_token'. Managed by the mixin.
    prevpeek  | .
    --------------------------------------------------------------------------------

    API:

        parse()
        eat()
        error()

RegexLexer:

    - General-purpose regex-based lexer.

    Attribute | Note
    --------------------------------------------------------------------------------
    text      | The text to be lexed.
    toktypes  | Sequence of TokenType.
    pos       | Current index of the lexer.
    mxpos     | Last index of the text.
    iseof     | Becomes True when text exhausted.
    --------------------------------------------------------------------------------

TokType:

    - Internal data object given to a lexer.

    Attribute | Note
    --------------------------------------------------------------------------------
    name      | Name of token.
    regex     | Regex to match the token.
    emit      | Whether to emit back to parser [default: True].
    --------------------------------------------------------------------------------

    Kinds:

        TODO

Token:

    - Simple internal data object emitted by a lexer.

    Attribute | Note
    --------------------------------------------------------------------------------
    toktype   | TokenType of the token.
    value     | Corresponding token text.
    pos       | Position (where matched)
    line      | Line number.
    col       | Column number.
    --------------------------------------------------------------------------------

    Kinds:

        TODO

ParseElem:

    TODO

    Kinds:

        variant
        group
        opt
        quantifier
        choices
        parameter
        literal

State:

    TODO

ArgResult:

    TODO

Target:

    - A data object used during argument parsing to store the
      information ultimately returned as a Result to end user.

    - For the applicable parsing interpretation, a Target contains information
      about all relevant Opt/Pos and values parsed so far.

    Attribute | Note
    --------------------------------------------------------------------------------
    poss      | List[Pos]
    opts      | Dict[Opt]
    vals      | Dict[DEST -> VAL]
    --------------------------------------------------------------------------------

