################################################################################
################################################################################
################################################################################
################################################################################

--------

# New parsing idea:

    - What is the problem with the current parsing approach?

        - The current code is not the issue: it won't handle the full grammar.
          A new implementation will be written one way or another.

        - Keep in mind that this parsing task probably fits reasonably well
          under the classic PEG algorithm. Be wary of abondoning that
          approach without specific reasons.

    - At run time, get the list of args to be parsed. That list will have N
      elements in it.

    - Start with the phrases.

    - For elements that have no inherent boundaries (eg, an option taking 1 or
      more args), interpret them in as bounded by using N as the upper limit.

    - Generate a full list of every concrete permutation (a) allowed by the
      phrases and (b) subject to the limit N.

    - Iterate over those permutations and see if any of them exactly match the args we
      are parsing.

    - The complexity lies not in doing highly-contextual parsing (which seems
      hard), but in generating the permutations (seems not too difficult) and
      then testing each permutation against the args (also not too difficult).

    - Search for "concrete alternatives" below for an example.

    - What causes a grammer to generate multiple possibilities?

        .              | Where expressed | Note
        -----------------------------------------------------
        Varying nargs  | Opt             | .
        Varying ntimes | Opt or Phrase   | Includes required.
        Aliases        | Opt             | .
        Alternatives   | Phrase          | Includes variants.

    - The library should provide an API alternative to the text-based grammar.

    - Some implementation notes:

        - Start with a more complex grammar from one of the unit tests.

        - Phrase
        - ConcretePhrase     # Static: no alternatives or varying nargs/ntimes

        - See Parser._do_alternative_parse(). This approach is not correct. I
          need to generate the cross-product from the top-level (not the
          Opt-level).

        - Can we drop the elaborate Lexer/classic-parsing stuff. It's heavy.
          Can't all of the needed parsing be done in one function with various
          helper utility functions? Both spec-parsing and arg-parsing.
          [Not sure this is a sound idea].

        - Don't forget about the need to support the parse_known() use case.

--------

## The configuration API

- See examples/odin-client-via-api.

- All options can be defined with fairly simple dictionaries, an approach
  similar to many option parsers, one with a key difference: it encourages the
  user to create a data structure rather than messing so much with API calls.

- The `option` key has a short syntax to define the option, short alias,
  arg_name, and nargs: '--job-config-file -c PATH'

- Several keys support a fully explicit syntax and a compact form for basic use
  cases.

- A list-of-dicts is sufficient for many command-line use cases. With that, the library
  could parse well and generate good usage text.

- If needed, the user could supply a grammar. Either way, the library will end
  up having a grammar that it could deliver back to the user (eg, for
  debugging).

- If desired, the user can customize the sections in the usage text, some of
  them hand-crafted and some of them generated by the library. In this way the
  user can control the key aspects of the usage: section ordering; section
  titles; layout style (eg, compact 2-column or man-page); capitalization
  rules; widths; and conventions for showing default values.

- Positional options (eg `task` below) are mostly like any other option: in
  particular they can take arguments. One difference is that the option always
  takes at least one argument -- the value itself.

--------

## Misc

- Should be intuitive and declarative, not based on a bizarre syntax or on
  user-created complex data structures.

- That said, the parser's configuration should be expressible as a data
  structure. This is important for testing, debugging, easy integration with
  config files, and using other libraries for data validation.

- If needed (eg, for complex applications) users should have full control over
  documentation. This includes both usage/help text and the styling of error
  messages.

- For quick-and-dirty projects, the module should generate automatic
  documentation based on requirements specified for the arguments and options.

- Should handle both positional arguments and options.

- Should have a design that is friendly to customization.

- Easy system for validators to be combined flexibly.

- Should be applicable to validating subroutine arguments, both positional and
  key-value.

- Should support subcommand applications, like svn or git.

- Should easily support different help types: (a) brief usage/synopsis, (b)
  full help or man-page, and (c) extras or examples.

- Include ability to merge options from several sources: ENV variables, config
  files, command-line options. Note that the purpose of the configuration
  sources (ENV vars and config files) is to set the default values used by the
  command-line option parser. When defaults are supplied, it should also cause
  a required option to become non-required (in other words, whenever default is
  set for an option, it forces required to become False).

- Combine the best of many approaches seen in other arg parsers.

- Make it easy to test the option parser.

- Error handling should be under the user's control, if they want it. This is a
  serious flaw in some parsers (eg argparse). The library should support both
  "automatic" mode (where the parser will eagerly print help or error-msg and
  quit) or non-automatic mode (where the parser will simply return an object
  containing all information and allow the user to decide what to do).

- If possible, allow users to customize by writing simple functions or hooks
  rather than having to subclass everything. Consider using the pluggy library
  so that users can implement simple function hooks.

- Start simple: begin with core behaviors; don't support more flexibility until
  a basic working system is in place.

- Convention over configuration: sensible defaults to allow the most common
  path to be followed with minimal setup.

- Support for --version. Show the application's name and version number.

- Provide helper functions for warn(), exit().

- Support both configuration styles: (1) Per-option configuration (eg, argparse
  and most other systems); and (2) thematic configuration (eg, set several
  default values at once, or several data-types at once).

- Allow the user to have hidden options (eg for developers only).

- The Click documentation criticizes the docopt approach, because the help text
  cannot be rewrapped in the face of different terminal widths. Point taken ...
  but so what: if the terminal is very wide, I still want the help text to be
  80 chars or less, for readability. And almost no one uses terminals less than
  80 characters wide.

- Usage text in man-page or command-line style.

- For file args, handle `-` as stdin or stdout.

- Add a --bash-completion option.

- Support @somefile.txt: user supplies command-line args via a file.

- Support file and dir types.

- Support parse_known_args() and parse_tolerant().

- Support allow_abbreviation boolean.

- Flexible parse: just accept any `--key VAL` pairs on the command line.

- Late parser config: configure parser; get args; call user's code; user can
  check args, and modify the parser at run-time

- When building usage text, allow control over opts-then-positionals vs
  positionals-then-opts.

- The continuum of use cases:

  - Zero configuration.
    - opts are flags
    - everything else goes in args

            opts = Parser().parse_args()

  - Mostly-zero configuration.
    - zero: True if zero is None and self.opts is empty

            p = Parser(
              Opts('--foo X', type = int)
              zero = True
            )

  - Bare-minimum configuration
    - User supplies a simple spec.
    - <x> for positionals.
    - X for option args.
    - All values are strings.

            spec = '-n NAME --foo --bar B1 B2 <x> <y>'
            p = Parser(simple = spec)

  - Basic configuration via API.
    - Similar to argparse.
    - But a more compact API.
    - More powerful and flexible.

  - Full control.
    - Fine tuned usage text.
    - command-line grammars.
    - Lots more.

--------

## Phrase objects

Attributes:

    subphrases      : []
    ntimes          : examples: N * + ? (m,n) (m,None), func, iterable of ints
    required        : not needed; can be handled by ntimes
    phrase_type     : OPT | POS | PHRASE | ZONE
    subphrase_logic : AND | OR
    anchored        : bool

The top-level Phrase represents the entire command-line grammar and is the root node
in a tree of Phrase objects.

The leaf nodes of the tree are always OPT or POS.

There needs to be restrictions on nodes in the tree that take variable N of
arguments. This applies especially to POS nodes with a varying ntimes attribute
and, in more limited ways, to OPT nodes that have a varying nargs attribute.

- The entire tree cannot contain more than one POS node with a variable
  ntimes attribute. Conceivably, a rule or policy could be applied
  to resolve the ambiguity created by multiple POS nodes with variable
  ntimes. But at least in the default case (ie, without such a policy)
  only one POS can have a variable ntimes.

- Similar issues arrive if an option resides in multiple leaves in the Phrase
  tree and if those Opt instances have varying ntimes attributes. For example,
  if -x is in one leaf with ntimes=(1,3) and also in another leaf with
  ntimes=(1,3), and if there are 4 -x options in the command-line args, there is not an
  unambiguous way to bind those command-line args to the leaves.

- A fairly obvious policy to resolve many such ambiguities:

  - Do not try to enforce against parser definitions with the possibility for
    ambiguous end-usages.

  - Instead, let programmers use the library as they see fit.

  - The consequence of that freedom: they will place some burden on end-users
    to arrange their command line in a non-ambiguous fashion (through opt and
    arg ordering and the use of the `--` marker).

  - Default to greedy left-to-right parsing (similar to regex), with back-off
    until the overall parse succeeds. Do not worry about possible alternative
    parses of the same arguments.

  - A later feature addition could be to have the parser find every successful
    parse and report an error if there is not exactly one.

- In addition, a POS node with variable ntimes and an OPT node with variable
  nargs raise similar ambituities -- at least in the absence of a
  policy. In this case, one possible policy is the use of `--` to signal
  the boundary between options and positional arguments.

Example 1:

    # Grammar:

    [-b]      [-x] [-y]   # -a and -b are mutex,
    [-a] [-c] [-x] [-y]   # and -b also allows -c

    # Phrase tree:

    PHR  (1,1)  OR

        PHR  (1,1)  AND
            OPT -b (0,1)
            OPT -x (0,1)
            OPT -y (0,1)

        PHR  (1,1)  AND
            OPT -a (0,1)
            OPT -c (0,1)
            OPT -x (0,1)
            OPT -y (0,1)

    # Concrete alternatives:

          -b -x -y -a -c
        ----------------

        #                 No args.

        #  .              -b scenarios
        #  .  .
        #  .     .
        #  .  .  .

        #           .     -a scenarios, without -c
        #     .     .
        #        .  .
        #     .  .  .

        #           .  .  -a scenarios, with -c
        #     .     .  .
        #        .  .  .
        #     .  .  .  .

Example 2:

    # Grammar:

    [-x]  [-z] <a>
    -y -x [-z] <a> [<b>]   # If -y, then -x is required and <b> is allowed.

    # Phrase tree:

    PHR  (1,1)  OR

        PHR  1  AND
            OPT -x (0,1)
            OPT -z (0,1)
            POS a  1

        PHR  1  AND
            OPT -y 1
            OPT -x 1
            OPT -z (0,1)
            POS a  1
            POS b  (0,1)

Example 3:

    # Grammar:

    [-x] [-y] (<a> <b> <c>)...

    # Phrase tree:

    PHR  (1,1)  AND

        OPT -x (0,1)

        OPT -y (0,1)

        PHR (1,None) AND
            POS a  1
            POS b  1
            POS c  1

Example 4:

    # Grammar:

    (-x | -y | -z -q) [-a] <b>

    # Phrase tree:

    PHR  (1,1)  AND

        PHR (1,1) OR

            OPT -x 1
            OPT -y 1
            PHR    1  AND
                OPT -z 1
                OPT -q 1

        OPT -a (0,1)
        POS b  1

Example 5:

    # Grammar:

    (-a -x | -b... | [-a] -c -d) [-e | -f] [-g] <h> [<i>...] ([-j -k]... | -m -n)

    # Phrase tree:

    PHR  (1,1)  AND

        PHR (1,1) OR

            PHR (1,1) AND
                OPT -a 1        # Note: -a could go here.
                OPT -x 1

            OPT -b (1,None)

            PHR (1,1) AND
                OPT -a (0,1)    # Note: or here.
                OPT -c 1
                OPT -d 1

        PHR (0,1) OR
            OPT -e 1
            OPT -f 1

        OPT -g (0,1)

        POS h (1,1)

        POS i (0,None)

        PHR 1 OR

            PHR (0,None) AND
                OPT -j 1
                OPT -k 1

            PHR 1 AND
                OPT -m 1
                OPT -n 1

Example 6:

    # Grammar:

    --foo F1 F2 -x -y <a> <b>

    # Phrase tree:

    PHR  (1,1)  AND
        OPT --foo 1  nargs=2
        OPT -x    1
        OPT -y    1
        POS a     1
        POS b     1

Example 7:

    # Grammar:

    (-x X1 -y Y1)...

    # Phrase tree:

    PHR  (1,None)  AND
        OPT -x 1  nargs=1
        OPT -y 1  nargs=1

Example 8:

    # Grammar:

    .general-options : [-m] [-n] [-o]
    configure        : [general-options] ; !task=configure --odin-env --od-user
    submit           : [general-options] ; !task=submit -c -r [--start-job]
    get              : [general-options] ; !task=get -j [--json [--indent] | --b64 | --yaml]
    help             : * --help
    zzz              : [-x] [-y] (<a> <b> <c> [-z])...{2,7}

    # Phrase tree:

    PHR  (1,1)  OR

        # configure
        PHR (1, 1) AND

            # general-options zone
            ZONE
                PHR 1 AND
                    OPT -m (0,1)
                    OPT -n (0,1)
                    OPT -o (0,1)

            ZONE
                PHR 1 AND
                    POS task 1         value=configure  anchored=True
                    OPT --odin-env 1
                    OPT --od-user  1

        # submit
        PHR (1, 1) AND

            # general-options zone
            ZONE
                ...

            ZONE
                PHR 1 AND
                    POS task 1         value=submit  anchored=True
                    OPT -c 1
                    OPT -r 1
                    OPT --start-job (0,1)

        # get
        PHR (1, 1) AND

            # general-options zone
            ZONE
                ...

            ZONE
                PHR 1 AND
                    POS task 1         value=get  anchored=True
                    OPT -j 1
                    PHR 1 OR
                        PHR 1 AND
                            OPT --json 1
                            OPT --indent (0,1)
                        OPT --b64 1
                        OPT --yaml 1

        # help
        PHR (1, 1) AND
            OPT --help 1      tolerant=True

        # zzz
        PHR (1, 1) AND
            OPT -x (0,1)
            OPT -y (0,1)
            PHR (2,7) AND
                POS a 1
                POS b 1
                POS c 1
                OPT -z (0,1)

--------

## Phrase.parse()

What causes the parsing to require alternatives and backtracking?

- Options that reside in multiple alternative locations in the Phrase tree. For
  example, when we encounter an -x among the command-line args, we do not know in
  advance which subphrase to bind it with:

        PHR OR
            PHR AND
                -x
                -z
            PHR AND
                -x
                -y

- Options that reside in multiple non-alternative locations in the Phrase tree,
  and where one of those leaves has a varying ntimes attribute. In this
  example, we do not know in advance how greedily to bind -x command-line args to the
  first leaf in the tree.

        PHR AND
            PHR AND
                -x  ntimes=(1,3)
            PHR OR
                PHR AND
                    -x  ntimes=1
                    -y
                PHR AND
                    -z
                    a

- Destinations for positional arguments with varying ntimes attributes or
  (closely related) options with varying nargs attributes. In these two
  examples, when we encounter a non-option command-line arg, we do not know in advance
  whether to bind it greedily:

        PHR AND
            POS a (1,3)
            POS b 1
            POS c 1

        PHR AND
            OPT -x nargs=(1,3)
            POS b 1
            POS c 1

Decisions when processing a command-line arg:

- Is it an option or non-option?

  - Option:

    - If it can bind to only one leaf in the Phrase tree, do so.

    - If there are alternatives leaves, collect them and prepare for possible
      backtracking. We will try each leaf in order.

  - Non-option:

    - Is there a current-option that can take args?

      - No: do not bind.
      - Yes, static: just bind.
      - Yes, variable: bind with possible backtracking.

    - Otherwise, we will bind to positional Opts.

      - Static: just bind.
      - Variable: bind with possible backtracking.

--------

## Returned data: nargs, ntimes, etc

General principles:

    VERDICT: I think this is a sound plan
    VERDICT: use nparams for options, nargs for positionals, and neither for literals

        An alternative:

            nparams : N of params (for options)
            nargs   : N args (for positionals and theoretically literals)
            ntimes  : Governs only optionality and repetition.

            Options:                    #  nparams  ntimes

                -y                      #  0        1
                [-y]                    #  0        (0,1)
                [-y {} {}]              #  2        (0,1)

            Positionals:                #  nargs    ntimes

                <x>                     #  1        1
                [<x>]                   #  1        (0,1)
                (<x> <x> <x>){0,2}      #  3        (0,1,2)

            Literals:                   #  nargs    ntimes

                (veg|meat)              #  .        1
                [veg|meat]{0,3}         #  .        (0,3)
                digits=(1|2|3|4)...     #  .        (1,None)
                ((x|y) (x|y)){1,3}      #  2        (1,3)

                Literals probably won't every need nargs in the real world, and
                those strange usages could be handled by nested ntimes
                configurations. That said, it might be just as simple from an
                implementation perspective to allow nargs for literals. A
                similar not-strictly-needed argument could be made for
                positionals: the last <x> example could be done with nested
                ntimes. But that would make the grammar syntax less readable.

  - The returned data will have attribute names corresponding to the configured
    Opt instances.

  - ntimes controlls optional/required behavior: is the thing (an option or
    positional) present and, if so, how many times?

  - nargs is straightforward for options: how many args does the option take?

  - For positionals, the nargs/ntimes distinction is not quite as obvious, but
    the optional/required note above points us in the right direction. For
    example:

        frob <x> <y> <y> [<z>]

        opt   nargs   ntimes
        --------------------
        x     1       1       # A typical positional: required with 1 arg.
        y     2       1       # Also required, but 2 args.
        z     1       (0,1)   # Optional, with 1 arg.

        Mnemonic:

            - nargs always counts the number of non-option arguments.

                --foo {} {}     # 2
                {x} {x}         # 2

            - ntimes counts what?

            - The need for a mnemonic is a warning sign.

  - Internally, a ParsedOpt will store all values in a 2D array:

      self._values = [
          [a1, a2, ...],  # First time.
          ...             # Etc.
      ]

  - But ParsedOpt.value will return a value flat as possible, based on nargs
    and ntimes (unless user requests non-flattened data). See the examples
    below.

Various nargs-ntimes combos and the returned data:

    nargs | ntimes | data | Note
    ----------------------------
    0     | 0, 1   | .    | .
    0     | 2+     | .    | .
    1     | 0, 1   | .    | .
    1     | 2+     | .    | .
    2+    | 0, 1   | .    | .
    2+    | 2+     | .    | .

  - nargs 0

        # ntimes 0 or 1     # ntimes 2+
        foo: True

                            foo: [                        Flattened
                                True,       First time
                                True,       Second
                                ...         Etc
                            ]

                            foo: [                        Non-flattened
                                [True],
                                [True],
                                ...
                            ]

  - nargs 1

        foo: a1

                            foo: [
                                a1,
                                a2,
                            ]

  - nargs 2+

        foo: [a1, a2, ...]

                            foo: [
                                [a1, a2, a3, ...],
                                [a1, a2, ...],
                                ...
                            ]

Positionals:

  - Example grammar and corresponding params:

        frob (<a> <a> <b> <c>){3} <d> [<e>]

            nargs  ntimes
        -----------------
        a   2      3
        b   1      3
        c   1      3
        d   1      1
        e   1      (0,1)

  - Example usage and returned data:

        frob  10 11 20 30  100 101 200 300  1000 1001 2000 3000  DD

        a: [
            [10, 11],      # First time.
            [100, 101],    # Second time.
            [1000, 1001],  # Third time.
        ],
        b: [
            20,
            200,
            2000,
        ],
        c: [
            30,
            300,
            3000,
        ],
        d: DD
        e: None

--------
Notes formerly in api_design.txt
--------

Eager option attachment at repetition boundaries:

    VERDICT: yes. Could be configurable if anyone ever needed.

    - In the `zzz` variant, blort-maker, a sequence of options/positionals can
      be occur 2 to 7 times.

    - If the -z option is provided by the user at a repeated-group boundary,
      we attach it to the first group eagerly.

    - For example:

        # Input.
        A1 B1 C1 -z A2 B2 C2      # -z with first group

        # ParseOption info.
        a : [A1,   A2]
        b : [B1,   B2]
        c : [C1,   C2]
        z : [True, False]

Notes about varying positionals:

    - Only 1 positional can occur a variable N of times.

    - Otherwise, we cannot allocate the values unambiguously.

    - For example, all of these are ambiguous:

        <a>... <b>... <c>
        <a>...{3} <b> <c>...{2} <d>
        (<a> <b>... <c>){2}

    - Varying positionals can be used with an option taking a
      varying nargs, provided that a reasonable parsing approach
      is used and users arrange their command-line arguments
      to avoid ambiguity.

Notes on --help:

    - VERDICT: yes, this plan is reasonable.

    - This example is premised on the idea that we are aiming for
      the following:

        frob --help              # Print general help.
        frob configure --help    # Print help for the configure task.

    - But how does the user configure this help dispatching. More generally,
      what about supporting other help-printing scenarios that rely not on
      `--help` but on some other options: for example, I've had programs where
      I want --examples to print some usage examples for the end-user.

        - Simple use case: standard help feature for a command-line program.

            p = Parser(help = True|False)

        - Help hook for ultimate flexibility: any time the library's help
          feature is triggered, call the user's function with some params and
          let them return something to tell the library which help section to
          print, if any. This approach is probably powerful, but it does not
          speak to simple use cases (standard help) or the most common type of
          complex use case (a program with subcommands, where the subcommands
          and help sections have a 1:1 correspondence).

            p = Parser(help = CALLABLE)

        - To support help dispatching base on subcommands.

            - Simple configuration:

                o = Opt('task', help = USE_SECTIONS)

                - Set the Opt's help param to a constant provided by the
                  library. If set, this tells the library to use the parsed
                  value of the Opt to select the help section whenever help is
                  triggered.

            - More flexible configuration:

                o = Opt('task', help = DICT)

                - The user maps the task values to help section names.

Grammar syntax: named and unnamed arguments:

    Positionals must be named:

        frob <a> <b> [<c>]

    Option arguments can be named or unnamed:

                                            # Value of parsed data in user code:
        frob --mode {group} {name} {n}      # - Data object with attributes.
        frob --mode {} {} {}                # - Tuple.

    Literals can be named or not:

        frob action=div <a> / <b>           # Literal forward slash.

        Unnamed literals won't be in the returned data for now. But support
        could be added later.

Top-level validation: for variants and overall:

    - VERDICT: maybe later.

    - It's not strictly needed, because validators will have contextual
      information about all other Opts.

    - But it could be handy. Without support for overall validation, users must
      do the validation and then call a method to emit the appropriate
      usage/error message to the end-user. With support, the validation just
      needs to return True/False.

Function signature for converters and validators:

    - The defaults:

        Function  | Arity | Signature
        ----------------------------------------------
        Converter | 1     | STR           => OBJ
        Validator | 2     | (PARSER, OBJ) => True/False

    - If needed a future feature:

        Opt(arity = (C, V))   # C and V can be 1 or 2.

Error message configuration:

    - An Opt should be able to control how conversion and/or validation
      failures should be reported.

API needs good syntax for retrieving grammar elements:

    g.get(NAME, NAME, ...)          # Get one.
    g.get(NAME, [NAME, ...], ...)   # Get multiple.

    - Support bulk configuration.

    - In user validation code, they need an easy way to get sibling Opt
      information.

Variants: are they needed?

    - VERDICT: yes for the full grammar. But you don't need it if you have only
      one variant -- no need for pointless variant naming.

    - Why do the variants have names? More broadly, are they really needed if
      we have alternation?

    - Some not-especially-good reasons:

        - Ability to refer to partials by name. This seems true, but
          we could solve partials a different way.

        - Better error reporting. Maybe, but you only need to report info
          about the variant if variants exist.

        - As a convenience for common subcommand use cases, help text could
          be linked to variant names in an automatic way. Maybe, but it
          probably makes more sense to do help-dispatch via the Opt rather
          than the variant.

    - Better reasons:

        - They were useful in the API grammar configuration examples.

        - The name is a useful handle, if nothing else and it might
          be handly later for other features.

Parsing must occur in phases:

    - Phase 1: argument type and conversion:

        - Correct arg type: positional, literal, option, option arg.
        - Conversion success.

    - Phase 2: validation.

Separators:

    VERDICT: grammar already support separators (eg nab).

    - Consider the nab use case.

        - Here we have a linear sequence commands:

            nab grep <> [-c] / split <> <> / item 1 / print

        - Because we don't know in advance what args the commands (grep, split,
          etc) will take, we need a command separator. The command names are
          not sufficient as separators, because some commands might have
          arguments with the same names.

    - How would the user convey the separators in the grammar? I think
      a partial would work:

        - notes elsewhere.

        VERDICT: this works.

    - That seems plausible, but how would returned data be organized?

        - In this case we have a quantified variant? That's new.

        - Two problems:

            VERDICT: not a problem.

            1. We need to link the repeated cmd to a name in the returned data.

            2. And somehow the library needs to know that the first cmd and the
            optional sequence of separator-plus-cmd should be unified under the
            same collection in the returned data.

                ### NOTE: not a problem. It's already the convention elsehwere
                and in my planning notes.

                - Thus, I don't think we need open-ending target assignment
                  for the know use cases.

        - This starts to seem awkward, but the first issue could be solved by
          generalizing the storage-target naming convention we already have.
          Let any element (or group of elements) in the grammar take a target
          name.

            VERDICT: general target assignment not needed

            - For example:

                main : config=([--size {}] [-x] [-z]) run=(<paths>... [--overwrite])

                In returned data:

                    opts.config : Data(size, x, z)
                    opts.run    : Data(paths, overwrite)

            - The nab use case:

                main : commands=(cmd` [ / cmd` ]...)

        - That might work but it's getting very complex visually. It this
          a case where the underlying API should do the work?

Variants: other possible features:

    - Unnamed variants: in the neck-diagram example, the 'main' variant
      isn't doing anything useful.

        VERDICT: it's not required. Smaller parts of the syntax will be used
        elsewhere. The parser needs to handle subsets of the full syntax.

    - Sub-variants.

        VERDICT: supportable, but not now.

        - That might seem like extra complexity, but it might not alter the
          difficulty by very much. We already have a tree-based approach for
          the grammar. Sub-variants just an a new level in the recursion.

        - Do we have any known use cases for subvariants? Not directly,
          but the neck-diagram example is suggestive. For example, take
          neck-diagram as an example, but add more restrictions:

Simple spec vs grammar spec:

    - VERDICT: abandon simple spec. Use the real grammar.

    - Is this separation needed?

    - Just convert simple spec to the official syntax

        # Instead of this.
        -n NAME --foo --bar B1 B2 <x> <y>

        # Do this.
        -n {} --foo --bar {} {} <x> <y>

    - And then allow the grammar to use variants (the complex case) or not.

Grammar syntax and the optionality of pure flags:

    VERDICT: syntax should be explicit about flag optionality.

    - On one hand, a flag option makes no sense being a required
      input. That would imply that syntax diagrams don't need
      square brackets around pure flags.

    - However, the convention appears to show usage syntax in
      explicit terms.

    - In this case, following convention seems wise.

Simplify the tentative syntax plan?

    - VERDICT: no.

    - Retain as archival planning thoughts.

        - Target name assignment for literals:

            for v in ('configure', 'submit', 'get', 'drop'):
                o = g.variants[v].convert_to_literal('configure', 'task')

            - That seems annoying and not intuitive.

            - VERDICT: retain.

        - Boolean OR:

            - This is an easy call: syntax is intuitive and API
              usage for this situation is annoying.

            - VERDICT: retain.

        - Quantifiers.

            - The ... is intuitive and practically a convention.

            - The {m,n} syntax directly mimics regex and is also
              quite intutive.

            - VERDICT: retain.

        - Partials.

            p1 = g.get('general')
            p1.config(partial = True)
            g.get('configure').insert('task', p1)

            - Also annoying: user must make two configurations.

            - And the partial syntax isn't heavy; in fact, I find the
              syntax more intuitive.

            - VERDICT: retain.

        - Zones and anchoring.

            names = ('configure', 'submit', 'get', 'drop')
            get.get(names).insert_zone(anchor = True)

            - API usage seems not too bad.

            - The zone syntax not too obtrusive, and its a mixture of
              intutive (zone) and not intuitive (anchor)

            - However, there' no benefit to supporting zones in syntax
              without anchors.

            - I suspect the desire for zones and anchoring is moderately
              low but still present.

            - VERDICT: retain, but take care to phase the documentation.

        - High precedence.

            g.get(['help', 'syntax']).config(high = True)

            - API is pretty easy.

            - But the syntax is neither heavy nor unintuitive.

            - Syntax is not hard to support.

            - VERDICT: retain.

Target assignment: needed after all:

    VERDICT: we do need generalized target assignment. Or, at a minimum,
    target assignment for Opt and Partial.

    - Consider examples like neck-diagram (nab is similar). The specific Opt
      targets (cmd, snum, syms, etc) will be nested underneath the 'commands'
      namespace (the outer target assignment). The returned data would have
      this structure:

        opts.commands : (
            Namespace(cmd = 'snum', snum = 6),
            Namespace(cmd = 'tuning', notes = ('E', 'A', ...)),
            Namespace(cmd = 'fret', syms = ('1', '3', '5')),
            ...
        )

    - Without the outer target assignment to 'commands`, the returned data
      would be grouped by the other target names -- which badly jumbles
      everything up:

        opts = Namespace(
            cmd   : ['snum, 'tuning', 'fnum', 'fret', 'fret', ...]
            snum  : ['6']
            fnum  : ['5']
            notes : [[...]]
            syms  : [[...], [...], ]
        )

Grammar via API:

    - Defining a grammar with the API is not unreasonable (shown below), but
      it's also verbose, not easily read/scanned, and less intutive that
      the text syntax.

    - Furthermore, the simplicity compounds. Most command-line scripts have
      simple needs. And those simple examples often shine under the syntax. The
      simplest occurs even inside the API usage -- namely, when defining Opt
      instances:

        Opt('--foo {a} {b}')      # Simpler and more powerful.
        Opt('-foo', nargs = 2)

    - That said, I suspect some future grammar features won't fit very easily
      in the syntax. So users need a way to create a grammar with syntax and
      then tweak it with API.

        - An example scenario and variant to illustrate: in order to group opts
          under a child namespace within the returned data (not known to be
          needed yet), we could generalize the target assignment syntax:

                main : config=([--size {}] [-x] [-z]) run=(<paths>... [--overwrite])

        - But that syntax solution is a bit noisy and opaque. An alternative is
          to keep syntax simple and let more complex configuration happen via
          API.

            # Basic syntax:

                main : [--size {}] -x -z <paths>... [--overwrite]

            # Additional API configuration:

                g = Grammar('SYNTAX ...')
                main = g.variants['main']
                main.group('--size', '-x', '-z', target = config)
                main.group('paths', 'overwrite', target = run)

End-user input error scenarios:

    VERDICT: this issue is manageable.

    - Conclusions:

        - Each parse() call will generate up to N failures (one per variant or,
          under the new parsing idea, one per concrete permutation).

        - Ideally, we would report the error most aligned with user intent.

        - Error types can guide that logic. Some errors are specific and
          telling with respect to intent; other tend to be disqualifying. And
          one type of error is so egregrious that intent does not matter.

    - Reporting precendence for errors:

        - First consider error precendence:

            - Global problems.
            - Conversion and validation problems.
            - Structural problems: non-options.
            - Structural problems: options.

        - Then check alignment between arguments and expectations.

            - Greater alignment implies intent.
            - Example metric: N Opts matched / N Opts

        - Finally, use input ordering within the grammar.

        - As a possible future feature, support verbose error reporting,
          triggered by env variables and/or Parser config via API.

    - Types of errors:

        - NOTE: order of the errors is important, but I'm not certain
          what the ordering trait is:

            - Precedence?

            - Specificity? Non-specific errors tend to be disqualifying
              (meaning, the current variant or concrete permutation is probably
              not applicable or intended) and specific errors tend to pull in
              the opposite direction (we know what the user intended, but the
              goofed up a detail).

            - Also, errors related to options are more specific or telling (an
              option is either known, compatible, and allowed ... or not) than
              non-options (which could be positionals or option arguments).

        - Global problems:

            * Errors that are true across all variants and groups. Intent does
              not matter. Reporting an unknown option is both true and helpful.

            - Unknown option: overall.

        - Structural problems: options:

            * Unknown, incompatible, or disallowed options. Compared to
              other error types, these are more disqualifying.

            - Incompatible options: a known option is not in the current
              variant/group. This means it is incompatible with whatever
              argument or option told us which variant/group we are in.

            - Mutually exclusive options: known options both belonging to the
              same Alternation instance.

            - Missing option: required option is not present.

        - Structural problems: non-options:

            * Invalid number of non-option arguments. Due to ambiguities
              between positionals and option arguments under some scenarios,
              these errors are somewhat less specific and more disqualifying
              than structural problems for options.

            - Too few/many arguments for an option (the latter applies when
              supplied grammar has no positionals).

            - Too few/many positionals.

        - Conversion and validation problems:

            * Here we have slotted all arguments into valid slots (none of the
              structure problems listed below), but the actual values don't
              pass muster. These failures are the most specific and telling
              with respect to intent.

            - Option arguments.

            - Positionals.

