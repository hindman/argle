--------

# New parsing idea:

    - Some additional questions:

        - What is the problem with the current parsing approach?

            - I don't know of a specific worry.

            - That said, the shape of the current Phrase.parse() does not seem
              capable of supporting anything other than a flat grammar.

            - So we are talking about a full refactor or a new approach.

        - The current approach follows classic algorithms (correction: this is
          true for grammar/spec parsing, I think, but not for the current
          Phrase.parse). Be wary of abondoning it in response to a vague worry.

    - At run time, get the list of args to be parsed. That list will have N
      elements in it.

    - Start with the phrases.

    - For elements that have no inherent boundaries (eg, an option taking 1 or
      more args), interpret them in as bounded by using N as the upper limit.

    - Generate a full list of every concrete permutation (a) allowed by the
      phrases and (b) subject to the limit N.

    - Iterate over those permutations and see if any of them exactly match the args we
      are parsing.

    - The complexity lies not in doing highly-contextual parsing (which seems
      hard), but in generating the permutations (seems not too difficult) and
      then testing each permutation against the args (also not too difficult).

    - Search for "concrete alternatives" below for an example.

    - What causes a grammer to generate multiple possibilities?

        .              | Where expressed | Note
        -----------------------------------------------------
        Varying nargs  | Opt             | .
        Varying ntimes | Opt or Phrase   | Includes required.
        Aliases        | Opt             | .
        Alternatives   | Phrase          | Includes variants.

    - The library should provide an API alternative to the text-based grammar.

    - Some implementation notes:

        - Start with a more complex grammar from one of the unit tests.

        - Phrase
        - ConcretePhrase     # Static: no alternatives or varying nargs/ntimes

        - See Parser._do_alternative_parse(). This approach is not correct. I
          need to generate the cross-product from the top-level (not the
          Opt-level).

        - Can we drop the elaborate Lexer/classic-parsing stuff. It's heavy.
          Can't all of the needed parsing be done in one function with various
          helper utility functions? Both spec-parsing and arg-parsing.
          [Not sure this is a sound idea].

--------
Items from prior road map
--------

- Don't worry about using simple dependencies: attrs, short_con.

- tox: py27 tests fail under tox (they pass under development virtualenv).

- Implement a proof-of-concept for the new parsing approach:

- asserts in code: don't rely on them for error checking

- GrammarSpecParser and complex Phrase parsing.
  - Planning.
  - Basic GrammarSpecParser implementation.
  - Complex grammars:
    - Varying nargs and ntimes.
    - Keeping track of partially-parsed results.
    - Pruning no-longer-eligible subphrases.
    - Keeping track of alternatives.
    - Backtracking using those alternatives.

- Support tolerant.

- Check argparse for other behaviors.

- Opt: allow `x` or `<x>`

- Handle --opt=val.

- Constructors should support dict-based configuration. Parser does, but not
  FormatterConfig and Section.

- help_text(): usage section: when wrapping, keep options together with their
  option args.

- Wildcards mode: allow user to specify pos/opt/both/True.

- nargs and ntimes: support regex-style quantifiers, both in specs and in the
  generated USAGE help-text.

- Negatable options: `--smart-case` and `--no-smart-case`.

- API thematic configuration.

- Help text customization.

- Support allow_abbreviation boolean.

- Option customization: eg, the regex to identify long opt, short opt, etc.

- Better exception strategy.

- Man-page support.

- Integration with configuration files.

- Integration with ENV variables.

- Miscellaneous.

----------------

# Tolerant options

    - NOTE: see api_design.txt for a more up-to-date decision making about this
      concept.

    - Search for "example 8".

    - In a case like that, if --help is among the args, a user still wants
      opto-py to parse as much as possible (eg, so the user can distinguish
      general help from help for a specific subcommand).

    - In other words, opto-py should attempt to parse the variants in the
      usual way, but if --help is present it should disregard end-user
      mistakes and keep parsing.

    - Some end-user mistakes will cause opto-py to misinterpret the situation.
      For example, `--fubb X configure` would cause opto-py to treat --fubb as
      an unknown option having nargs=0 and then treat X as the first
      positional, assigning it to task. (The user's code could still do the
      right thing by checking whether `configure` is among the positionals
      rather than just looking at task-positional).

    - Nonetheless, opto-py should do what it can.

    - And will tolerant options be fairly limited (eg, `* --help`, which means
      "accept anything if --help is present") or will users be allowed to
      define more complex grammars that trigger tolerant parsing: for example,
      `* --foo X task=blort --info`, which means "accept anything if several
      things are present.

    - More broadly, should tolerance be an attribute of the variant or of
      an opt?

    - This discussion makes me think tolerance should not be a variant
      attribute. What users want is for opto-py to parse options in the normal
      way (to the extent feasible) while overlooking end-user mistakes if a
      specific opt is present (--help, --version, etc). If this is sound logic,
      the "example 8" grammar should not have a help-variant; rather, something
      like [* --help] should be added to all of the other variants.

    - If we use that approach, how does the user express the grammar? For
      example, appending `[* --help]` to the end of every variant seems
      incorrect, because we should allow --help to be present in any zone of of
      each variant.

    - At least in complex cases (with variants and anchors), requiring the user
      to express tolerant opts within the grammar would be unhelpful,
      cluttering things up with little benefit. Although in the actual case of
      "Example 8", the problem is easy for the user, who could also include a
      tolerant --help in the general-options. Meanwhile, in simple cases,
      adding a tolerant opt to the grammar would be easy. And it's conceivable
      that a user might want a tolerant opt only for certain variants.

    - One approach might be the following:

        - If a user needs fine-grained control, they can specify tolerant opts
          in the grammar.

        - But also let them add tolerant opts via API convenience methods that
          would do things like add this tolerant opt to (a) all zones in a
          variant, or (b) to everything.

        - Additionally, the grammar could support a syntax for those
          conveniences:

            [* --help]    # normal
            [** --help]   # all zones
            [*** --help]  # everywhere (would be set in its own pseudo-variant)

--------

# Terminology

Users:

  - Library: the opto-py code base.
  - User: a developer using opto-py.
  - End-user: a user running a program that uses opto-py.

Command line components:

  - For example:

        frob (find | copy) <path> [--verbose] [--type (file | dir | link)] [--rgx <patt>]

  - Positional arguments
    - Literal: `(find | copy)`
    - Variable: `<path>` or `PATH`

  - Options
    - Flags: `--verbose`
    - Non-flags: `--type` and `--rgx`

  - Option arguments
    - Literal: `(file | dir | link)`
    - Variable: `<patt>` or `PATT`

Help text sections:

  - CLI style:
    - Usage.
    - Positional arguments.
    - Options and/or option groups.
    - Custom sections.

  - Man-page style:

    - NAME
    - SYNOPSIS
    - DESCRIPTION
    - OPTIONS
    - Custom sections.

  - Terminology in opto-py:
    - Usage text: conveys the CLI grammar.
    - Options text: documents the options and positional arguments, perhaps in groups.
    - Custom sections.

--------

## Key points

There are two fundamental configuration strategies:

  - API-driven:

    - User configures a parser via the programmatic API.

    - The parser generates the help text.

    - Typically allows user to override with literal help text, if desired.

    - Examples: argparse and many others.

  - Text-driven:

    - User writes literal usage and options text.

    - Library derives the parser from that text.

    - This approach is much less common.

    - Examples: docopt.

The octo-py library combines the approaches:

  - In most respects, it is API-driven.

    - Tends to require less typing.

    - Generated usage text is mostly fine, especially for simpler projects.

    - Most developers probably prefer an API-driven approach over
      hand-formatting help text themselves.

    - API-generated help text will follow the conventions for documenting
      command-line programs -- conventions that few developers have studied in
      depth and would rather not worry about.

    - Examples confirming these points:

        # Simple programs.
        examples/get-pocket-items
        examples/daily-reading

        # More complex examples: contrast the API vs the text examples.
        misc/examples/odin-client-via-api
        misc/examples/odin-client-via-api-thematic
        misc/examples/odin-client-via-text
        misc/examples/odin-client-via-text-subparsers

  - Nonetheless, text-driven option parsers have some advantages:

    - Text-driven parsers emphasize the idea of **usage variants**, a technique
      that can greatly enhance usage-text readability -- both for simple
      programs and especially for complex programs:

            # Simple.
            frob [--debug] [--foo <f>] <path>...
            frob --help
            frob --version

            # Complex.
            git diff [options] [<commit>] [--] [<path>...]
            git diff [options] --cached [<commit>] [--] [<path>...]
            git diff [options] <commit> <commit> [--] [<path>...]

    - API-driven parsers struggle with command-lines that need any grammar that
      falls beyond the most typical cases (eg, mutually-exclusive groups and
      subcommands). On stackoverflow and bugs.python.org, for example, one can
      find many CLI use cases (some of them quite simple) that are not
      supported easily by argparse but that are straightforward in docopt.

    - And when users discuss CLI-grammar scenarios, they invariably use a
      text-oriented approach to specify the problem. In my own research, I
      experimented with defining the needed grammars via an API, but I always
      found the text-based approach simpler to express and read.

    - For those reasons, opto-py encourages a compact text-based configuration
      syntax for expressing the CLI grammar. That syntax does not try to
      address other option configurations (data types, choices, etc), and it is
      not literal usage text. Rather, it is an intuitive mechanism for
      configuring a CLI grammar. The grammar is also configurable via an API,
      but most users will prefer the simple text syntax.

    - Also, for most use cases a simple specification like `--foo F1 F2` is an
      easy way to declare an option --foo with nargs=2 and arg names F1 and F2.

Although opto-py is primarily an API-driven library, it also aims to address
some key weaknesses found in most parsing libraries.

  - Providing users with simple ways to handle CLI grammars and usage variants
    (just noted).

  - Supporting everything from quick-and-dirty scripts to complex, highly
    customized CLI programs, with other variants in between.

    - At once extreme, opto-py allows you to parse a standard command line with
      zero configuration. Just import and go.

            import opto_py
            opts = opto_py.parse_args()

    - At the other extreme, you could build the next Git or a variety of
      programs with idiosyncratic grammars, heavily customized help text, and
      many other features.

    - Sitting between the two extremes are numerous conveniences and sensible
      defaults to make option parsing easy, no matter what level of control
      your application needs.

  - Allowing users to control the generated help text in a fine-grained manner.
    One core premise of opto-py is that program complexity increases the need
    to organize and fine-tune help text, but not necessarily to hand-craft it.
    Some examples:

    - Simple top-level configurations to control basic layout, capitalization,
      punctuation, etc.

    - Support for common styles: CLI vs man-page.

    - Ability to group options into sections.

    - Ability to supply hand-crafted sections whenever needed and to
      locate those sections with precision in the output.

    - Ability to control virtually every aspect of the help text contruction
      process via basic functions (no need to subclass or dig into the parser's
      private methods and attributes).

  - Allowing users to enhance usage-text readability by being able to refer to
    groups of options and to omit either short or long options.

    - API-generated usage text tends to be poor not only because it lacks usage
      variants but also because the generated text exhaustively lists all
      options in all of their permutations (short and long).

    - Especially as the number of options grows, readability can be improved
      greatly by referring to sets of options by symbolic names rather than by
      enumerating every possibility.

    - Similarly, readability can be enhanced by focusing the usage text on just
      the long-options (or just the short-options) and then providing a mapping
      between short and long options latter in the help text.

  - Allowing users to define their arguments and options in ways that encourage
    modularity.

    - In opto-py a user defines options and arguments as atomic units, separate
      from the issues of CLI grammar, usage variants, and options help text.

    - Each of those atomic units can be assigned to one or more groups of
      related options.

    - Then those options or option-groups can be leveraged when defining the
      CLI grammar, when expressing the generated usage text, and when
      organizing the options text into sections.

  - Providing users with full access to the parser configuration, both via the
    API and in the form of standard, serializable data structures.

Key insights from other tools:

    - Tool must parse both options and positionals.

    - Customizable help text.

    - Need to support other formats (eg, POD or man pages).

    - Use hooks for customization by the user, not subclasses.

    - Prioritize the simple use cases. Yes, add features and customization
      capability. But do that without sacrificing super super usage patterns.

    - Tool must support conversion/validation. Without validation, providing
      good user error information is impossible.

    - Maybe support the tool's usages for simple conversion/validation of
      arguments to functions.

------------------

Page width formatting in help text:

    - By default, operate within these boundaries:

        min_width = 40
        max_width = 100

    - Within those parameters, respect the current terminal width, if known.

    - User-supplied text:

        - Break into paragraphs (but preserve info about N of blank lines between
          paragraphs).

        - Rewrap to the desired width (probably using textwrap module).

        - Leave indented paragraphs as-is.

        - Provide an easy syntax for users to suppress line wrapping
          within the text (eg something borrowed from markdown)

--------

API: FormatterConfig example:

    p = Parser(

        Opt(
            '--blort',
            text = '',
            sections = ['foo', 'bar'],             # Can be str or list/tuple/set.
        ),

        formatter_config = FormatterConfig(

            # Either Section or iterable.
            # Default label: "Foo options"
            Section('usage', label = '...'),
            Section('foo'),
            Section('bar'),
            Section('short-opts'),
            Section('special-notes', text = SPECIAL_NOTES, label = 'Special notes'),
            Section('warnings', text = WARNINGS, label = 'Warnings'),

            program_name        = '',
            section_label_punct = ':',
            after_section_label = '',
            after_section       = '\n',

            program_summary    = '',
            style              = CLI|MAN,
            opt_style          = CLI|MAN,

        ),

    )

    Section
        name  | Short; used symbolically (eg in grammar).
        label | Used in help text

--------

## Why opto-py does not include subparser features

Adding the subcommand/subparser concept to an option parsing brings a bunch of
new syntax. And ultimately, the subparser concept is much less flexible (and
less intuitive) than supporting the key concepts noted above: (1) usage
variants, and (2) command line grammar.

Very few CLI tools need a full-blown subparser strategy, especially if the
option parsing library provides good support for variants and CLI grammars.

And even if we were building the next Git, we would not need the subparser
in an option parsing library. We would just do this instead:

- Use a general parser:

        git [general-options] <subcommand> [args]

- Then parse `args` with the appropriate parser, based on the value of
  `subcommand`. As long as the library makes it easy to merge the
  general-options with the subcommand-options, there is no benefit
  to modeling the library to include a subparser concept.

In other words, a complex program does not need subparsers; it just needs N
parsers.

The opto-py library will support use cases like this by providing easy ways to
combine the opts obtained from both the top-level parse and the subcommand
parse -- both the ability to fully merge those two sets of options or to keep
them separately namespaced (eg, Git uses `-C` both and the top level and in
subcommands like `git-diff`).

--------

## Does Opt class need an action attribute?

No. The argparse library basically uses the action paramenter to
control the option type and thus the grammar.

    Action       | Option type       | Example         | Stored      | Notes
    ----------------------------------------------------------------------------------
    store_true   | 1 flag            | --frob          | True        | True == 1
    count        | 1+ flags          | -v -v           | N           | .
    store        | Single            | --foo F         | F           | .
    append       | Repeatable single | -x A -x B       | [A, B]      | Overwrite on repeat
    extend       | Repeatable multi  | -x A B -x C D E | [A B C D E] | .
    help         | High precedence   | .               |             | .
    version      | "    "            | .               | .           | .
    ----------------------------------------------------------------------------------
    store_false  | 1 flag            | --frob          | False       | Not necessary
    store_const  | 1 flag            | --frob          | X           | Not necessary
    append_const | 1+ flag           | --frob --frob   | [X x]       | Not necessary

--------

## CLI grammars

First start with the normal rules of CLI grammar, as commonly understood:

  - Positional arguments are ordered among each other:

        P1 P2 P3 ...

  - Options can be ordered in any way:

        --x4 --x1 --x3 --x2 ...

  - Options can be freely interspersed among the ordered positional arguments.

        --x3 P1 --x1 --x4 P2 --x2 P3 ...

In addition, a CLI grammar can have boundary points:

  - Each boundary creates a division between "zones" in a given usage variant.

  - Within a zone, the grammar can require that one or more positional
    arguments and/or options appear first, in order.

Side note on CLI grammars relative to regexes:

  - opto-py will borrow many concepts from regular expressions.

  - But CLI grammar parsing seems not directly amenable to handling via regex
    parsing approaches.

  - The crucial difference:

    - Positionals are ordered among themselves.

    - Options can appear in any order (ignoring boundaries and anchors).

  - That special flexibility makes it not very intuitive to convert a CLI
    grammar into a corresponding regex-style grammar.

      - At every stage, any of the options are possible.
      - But then once an option appears, it cannot appear again (ignoring repeatables).
      - That means CLI parsing is highly context-sensitive.

Within those rules in mind, we can handle the grammar of a typical subcommand
program as follows:

  - For example:

        frob [general-options] ; !<subcommand> <x> <y> [-a] [-b]

        General options:
          --log
          --debug

  - Requirements of that grammar:

    - Zone 1: some general options in any order.

    - Boundary point.

    - Zone 2: first the subcommand and then other positional args and options
      using the normal rules.

  - Usage examples:

        # Valid.
        frob               delete X Y
        frob --log         diff   X Y -a -b
        frob --log --debug copy   -a X -b Y

        # Invalid.
        frob --log -a diff X Y

  - A complex CLI with multiple layers of subcommands:

        frob [optsA]
             ; !<comm1> !<a> <b> <c> [optsB]
             ; <comm2> <d> <e> [optsC]
             ; !<comm3> !<h> !<i> [optsD]

  - The grammar has 4 zones:

    - optsA:
      - Normal rules.

    - comm1
      - Two positionals must appear first, then normal rules.
      - Note: optsA must be to left of comm1, and optsB to right.

    - comm2
      - Normal rules.
      - Note: either comm2 or any optsC means that no more optsB can appear.

    - comm3
      - Three positionals must appear first, and then normal rules.

  - You do not need a way to anchor items to the end of a zone. [I now
    think this might be wrong; see last part of this example.]

    - Imagine that we wanted to adjust the grammar to require two positionals
      at the end of the comm2 zone:

            frob [optsA]
                 ; !<comm1> !<a> <b> <c> [optsB]
                 ; <comm2> <d> <e> [optsC] <f>! <g>!
                 ; !<comm3> !<h> !<i> [optsD]

    - We could achieve that instead by establishing a new zone:

            frob [optsA]
                 ; !<comm1> !<a> <b> <c> [optsB]
                 ; <comm2> <d> <e> [optsC] ; <f> <g>
                 ; !<comm3> !<h> !<i> [optsD]

    - The potential PROBLEM: in organizing the parsed data, the user probably
      wants <f> and <g> linked to <comm2> -- at least that's my assumption. But
      are such cross-zone data linkages the way most users want the parsing to
      behave?

Handling literal option-arg choices.

- Consider these examples:

        frob (find|copy|delete) <path> --type (file|dir|link) --rgx <patt>

        frob --group (a|b|c|d) (x|y)

- Both raise ambiguities: are `--type` and `--group` flags or options that take
  literal args?

- Or here: is --group a flag or an option taking one, or even two, args?

        frob --group <g> (x|y)

- The equal-sign syntax seems to clarify, but it helps only for the case when
  nargs=1.

        frob --group=(a|b|c|d) (x|y)

- We could use curly braces only for literal option-args, but that doesn't
  provide a way to specify variable option-args.

        frob --group {a|b|c|d} (x|y)

- The way to resolve these problems is as follows:

  - If an option takes args, the option-phrase must be enclosed in brackets,
    either square or round.

        (-x <x1> <x2>)
        [-y Y]
        [-z Z1...]

    - The CLI grammar rule is that if brackets begin with an option, the
      remaining args inside the brackets are option-args, not positionals.

    - With this convention in place, expressing literal option-args is
      straightforward too. For example, this option takes 3 args, the first 2
      are literal-choices and the last is a variable-arg:

            (-x (a|b|c) (d|e) <x>)

    - And it even becomes possible to define grammar variants based on literal
      option-args values. For example, we can elaborate on the previous
      example, creating 3 variants driven by literal option-arg values:

            (-x (b|c) d <x1>)
            (-x a     e <x1> <x2>)
            (-x a     d <x1> <x2> <x3>)

- The SimpleSpecParser glosses over these issues via some assumptions:

  - It does not support literal args.

  - It uses different syntaxes for variable args: option vs positional:

        --foo F1 F2 <x1> <x2>

--------

## The configuration API

- See examples/odin-client-via-api.

- All options can be defined with fairly simple dictionaries, an approach
  similar to many option parsers, one with a key difference: it encourages the
  user to create a data structure rather than messing so much with API calls.

- The `option` key has a short syntax to define the option, short alias,
  arg_name, and nargs: '--job-config-file -c PATH'

- Several keys support a fully explicit syntax and a compact form for basic use
  cases.

- A list-of-dicts is sufficient for many CLI use cases. With that, the library
  could parse well and generate good usage text.

- If needed, the user could supply a grammar. Either way, the library will end
  up having a grammar that it could deliver back to the user (eg, for
  debugging).

- If desired, the user can customize the sections in the usage text, some of
  them hand-crafted and some of them generated by the library. In this way the
  user can control the key aspects of the usage: section ordering; section
  titles; layout style (eg, compact 2-column or man-page); capitalization
  rules; widths; and conventions for showing default values.

- Positional options (eg `task` below) are mostly like any other option: in
  particular they can take arguments. One difference is that the option always
  takes at least one argument -- the value itself.

--------

## Misc

- Should be intuitive and declarative, not based on a bizarre syntax or on
  user-created complex data structures.

- That said, the parser's configuration should be expressible as a data
  structure. This is important for testing, debugging, easy integration with
  config files, and using other libraries for data validation.

- If needed (eg, for complex applications) users should have full control over
  documentation. This includes both usage/help text and the styling of error
  messages.

- For quick-and-dirty projects, the module should generate automatic
  documentation based on requirements specified for the arguments and options.

- Should handle both positional arguments and options.

- Should have a design that is friendly to customization.

- Easy system for validators to be combined flexibly.

- Should be applicable to validating subroutine arguments, both positional and
  key-value.

- Should support subcommand applications, like svn or git.

- Should easily support different help types: (a) brief usage/synopsis, (b)
  full help or man-page, and (c) extras or examples.

- Include ability to merge options from several sources: ENV variables, config
  files, command-line options. Note that the purpose of the configuration
  sources (ENV vars and config files) is to set the default values used by the
  command-line option parser. When defaults are supplied, it should also cause
  a required option to become non-required (in other words, whenever default is
  set for an option, it forces required to become False).

- Combine the best of many approaches seen in other arg parsers.

- Make it easy to test the option parser.

- Error handling should be under the user's control, if they want it. This is a
  serious flaw in some parsers (eg argparse). The library should support both
  "automatic" mode (where the parser will eagerly print help or error-msg and
  quit) or non-automatic mode (where the parser will simply return an object
  containing all information and allow the user to decide what to do).

- If possible, allow users to customize by writing simple functions or hooks
  rather than having to subclass everything. Consider using the pluggy library
  so that users can implement simple function hooks.

- Start simple: begin with core behaviors; don't support more flexibility until
  a basic working system is in place.

- Convention over configuration: sensible defaults to allow the most common
  path to be followed with minimal setup.

- Support for --version. Show the application's name and version number.

- Provide helper functions for warn(), exit().

- Support both configuration styles: (1) Per-option configuration (eg, argparse
  and most other systems); and (2) thematic configuration (eg, set several
  default values at once, or several data-types at once).

- Allow the user to have hidden options (eg for developers only).

- The Click documentation criticizes the docopt approach, because the help text
  cannot be rewrapped in the face of different terminal widths. Point taken ...
  but so what: if the terminal is very wide, I still want the help text to be
  80 chars or less, for readability. And almost no one uses terminals less than
  80 characters wide.

- Usage text in man-page or CLI style.

- For file args, handle `-` as stdin or stdout.

- Add a --bash-completion option.

- Support @somefile.txt: user supplies CLI args via a file.

- Support file and dir types.

- Support parse_known_args() and parse_tolerant().

- Support allow_abbreviation boolean.

- Flexible parse: just accept any `--key VAL` pairs on the command line.

- Late parser config: configure parser; get args; call user's code; user can
  check args, and modify the parser at run-time

- When building usage text, allow control over opts-then-positionals vs
  positionals-then-opts.

- The continuum of use cases:

  - Zero configuration.
    - opts are flags
    - everything else goes in args

            opts = Parser().parse_args()

  - Mostly-zero configuration.
    - zero: True if zero is None and self.opts is empty

            p = Parser(
              Opts('--foo X', type = int)
              zero = True
            )

  - Bare-minimum configuration
    - User supplies a simple spec.
    - <x> for positionals.
    - X for option args.
    - All values are strings.

            spec = '-n NAME --foo --bar B1 B2 <x> <y>'
            p = Parser(simple = spec)

  - Basic configuration via API.
    - Similar to argparse.
    - But a more compact API.
    - More powerful and flexible.

  - Full control.
    - Fine tuned usage text.
    - CLI grammars.
    - Lots more.

--------

## Grammar-configuration syntax

- NOTE: see api_design.txt for more detailed, up-to-date notes.

- The grammar-configuration syntax will look roughly like usage text.

- But it will be more compact, easier to type, and easier to scan visually and
  grasp quickly.

- And it will include a small number of additional syntax elements focused on
  issues of CLI grammar.

  - Variants and their names.
  - Ability to refer to entire groups of options.
  - Zone boundaries.
  - Anchored items.
  - Destinations for literal-positionals.
  - Fully tolerant variants.

- General syntax:

        VARIANT_NAME : VARIANT_SPEC

- An example:

        get : [general-options] ; !task=get (-j XX) [--json [--indent] | --b64 | --yaml]

- Syntax elements:

        :         # divider between variant-name and variant-spec

        []        # grouping + optional
        ()        # grouping + required
        |         # logical OR
        {n1,n2}   # quantifier

        -x        # short option
        --zoo     # long option

        <x>       # variable argument (supplied by end-user)
        X         # ditto
        x         # literal argument

        ;         # zone boundary
        !         # anchor

--------

## Phrase objects

Attributes:

    subphrases      : []
    ntimes          : examples: N * + ? (m,n) (m,None), func, iterable of ints
    required        : not needed; can be handled by ntimes
    phrase_type     : OPT | POS | PHRASE | ZONE
    subphrase_logic : AND | OR
    anchored        : bool

The top-level Phrase represents the entire CLI grammar and is the root node
in a tree of Phrase objects.

The leaf nodes of the tree are always OPT or POS.

There needs to be restrictions on nodes in the tree that take variable N of
arguments. This applies especially to POS nodes with a varying ntimes attribute
and, in more limited ways, to OPT nodes that have a varying nargs attribute.

- The entire tree cannot contain more than one POS node with a variable
  ntimes attribute. Conceivably, a rule or policy could be applied
  to resolve the ambiguity created by multiple POS nodes with variable
  ntimes. But at least in the default case (ie, without such a policy)
  only one POS can have a variable ntimes.

- Similar issues arrive if an option resides in multiple leaves in the Phrase
  tree and if those Opt instances have varying ntimes attributes. For example,
  if -x is in one leaf with ntimes=(1,3) and also in another leaf with
  ntimes=(1,3), and if there are 4 -x options in the CLI args, there is not an
  unambiguous way to bind those CLI args to the leaves.

- A fairly obvious policy to resolve many such ambiguities:

  - Do not try to enforce against parser definitions with the possibility for
    ambiguous end-usages.

  - Instead, let programmers use the library as they see fit.

  - The consequence of that freedom: they will place some burden on end-users
    to arrange their command line in a non-ambiguous fashion (through opt and
    arg ordering and the use of the `--` marker).

  - Default to greedy left-to-right parsing (similar to regex), with back-off
    until the overall parse succeeds. Do not worry about possible alternative
    parses of the same arguments.

  - A later feature addition could be to have the parser find every successful
    parse and report an error if there is not exactly one.

- In addition, a POS node with variable ntimes and an OPT node with variable
  nargs raise similar ambituities -- at least in the absence of a
  policy. In this case, one possible policy is the use of `--` to signal
  the boundary between options and positional arguments.

Example 1:

    # Grammar:

    [-b]      [-x] [-y]   # -a and -b are mutex,
    [-a] [-c] [-x] [-y]   # and -b also allows -c

    # Phrase tree:

    PHR  (1,1)  OR

        PHR  (1,1)  AND
            OPT -b (0,1)
            OPT -x (0,1)
            OPT -y (0,1)

        PHR  (1,1)  AND
            OPT -a (0,1)
            OPT -c (0,1)
            OPT -x (0,1)
            OPT -y (0,1)

    # Concrete alternatives:

          -b -x -y -a -c
        ----------------

        #                 No args.

        #  .              -b scenarios
        #  .  .
        #  .     .
        #  .  .  .

        #           .     -a scenarios, without -c
        #     .     .
        #        .  .
        #     .  .  .

        #           .  .  -a scenarios, with -c
        #     .     .  .
        #        .  .  .
        #     .  .  .  .

Example 2:

    # Grammar:

    [-x]  [-z] <a>
    -y -x [-z] <a> [<b>]   # If -y, then -x is required and <b> is allowed.

    # Phrase tree:

    PHR  (1,1)  OR

        PHR  1  AND
            OPT -x (0,1)
            OPT -z (0,1)
            POS a  1

        PHR  1  AND
            OPT -y 1
            OPT -x 1
            OPT -z (0,1)
            POS a  1
            POS b  (0,1)

Example 3:

    # Grammar:

    [-x] [-y] (<a> <b> <c>)...

    # Phrase tree:

    PHR  (1,1)  AND

        OPT -x (0,1)

        OPT -y (0,1)

        PHR (1,None) AND
            POS a  1
            POS b  1
            POS c  1

Example 4:

    # Grammar:

    (-x | -y | -z -q) [-a] <b>

    # Phrase tree:

    PHR  (1,1)  AND

        PHR (1,1) OR

            OPT -x 1
            OPT -y 1
            PHR    1  AND
                OPT -z 1
                OPT -q 1

        OPT -a (0,1)
        POS b  1

Example 5:

    # Grammar:

    (-a -x | -b... | [-a] -c -d) [-e | -f] [-g] <h> [<i>...] ([-j -k]... | -m -n)

    # Phrase tree:

    PHR  (1,1)  AND

        PHR (1,1) OR

            PHR (1,1) AND
                OPT -a 1        # Note: -a could go here.
                OPT -x 1

            OPT -b (1,None)

            PHR (1,1) AND
                OPT -a (0,1)    # Note: or here.
                OPT -c 1
                OPT -d 1

        PHR (0,1) OR
            OPT -e 1
            OPT -f 1

        OPT -g (0,1)

        POS h (1,1)

        POS i (0,None)

        PHR 1 OR

            PHR (0,None) AND
                OPT -j 1
                OPT -k 1

            PHR 1 AND
                OPT -m 1
                OPT -n 1

Example 6:

    # Grammar:

    --foo F1 F2 -x -y <a> <b>

    # Phrase tree:

    PHR  (1,1)  AND
        OPT --foo 1  nargs=2
        OPT -x    1
        OPT -y    1
        POS a     1
        POS b     1

Example 7:

    # Grammar:

    (-x X1 -y Y1)...

    # Phrase tree:

    PHR  (1,None)  AND
        OPT -x 1  nargs=1
        OPT -y 1  nargs=1

Example 8:

    # Grammar:

    .general-options : [-m] [-n] [-o]
    configure        : [general-options] ; !task=configure --odin-env --od-user
    submit           : [general-options] ; !task=submit -c -r [--start-job]
    get              : [general-options] ; !task=get -j [--json [--indent] | --b64 | --yaml]
    help             : * --help
    zzz              : [-x] [-y] (<a> <b> <c> [-z])...{2,7}

    # Phrase tree:

    PHR  (1,1)  OR

        # configure
        PHR (1, 1) AND

            # general-options zone
            ZONE
                PHR 1 AND
                    OPT -m (0,1)
                    OPT -n (0,1)
                    OPT -o (0,1)

            ZONE
                PHR 1 AND
                    POS task 1         value=configure  anchored=True
                    OPT --odin-env 1
                    OPT --od-user  1

        # submit
        PHR (1, 1) AND

            # general-options zone
            ZONE
                ...

            ZONE
                PHR 1 AND
                    POS task 1         value=submit  anchored=True
                    OPT -c 1
                    OPT -r 1
                    OPT --start-job (0,1)

        # get
        PHR (1, 1) AND

            # general-options zone
            ZONE
                ...

            ZONE
                PHR 1 AND
                    POS task 1         value=get  anchored=True
                    OPT -j 1
                    PHR 1 OR
                        PHR 1 AND
                            OPT --json 1
                            OPT --indent (0,1)
                        OPT --b64 1
                        OPT --yaml 1

        # help
        PHR (1, 1) AND
            OPT --help 1      tolerant=True

        # zzz
        PHR (1, 1) AND
            OPT -x (0,1)
            OPT -y (0,1)
            PHR (2,7) AND
                POS a 1
                POS b 1
                POS c 1
                OPT -z (0,1)

--------

## Phrase.parse()

What causes the parsing to require alternatives and backtracking?

- Options that reside in multiple alternative locations in the Phrase tree. For
  example, when we encounter an -x among the CLI args, we do not know in
  advance which subphrase to bind it with:

        PHR OR
            PHR AND
                -x
                -z
            PHR AND
                -x
                -y

- Options that reside in multiple non-alternative locations in the Phrase tree,
  and where one of those leaves has a varying ntimes attribute. In this
  example, we do not know in advance how greedily to bind -x CLI args to the
  first leaf in the tree.

        PHR AND
            PHR AND
                -x  ntimes=(1,3)
            PHR OR
                PHR AND
                    -x  ntimes=1
                    -y
                PHR AND
                    -z
                    a

- Destinations for positional arguments with varying ntimes attributes or
  (closely related) options with varying nargs attributes. In these two
  examples, when we encounter a non-option CLI arg, we do not know in advance
  whether to bind it greedily:

        PHR AND
            POS a (1,3)
            POS b 1
            POS c 1

        PHR AND
            OPT -x nargs=(1,3)
            POS b 1
            POS c 1

Decisions when processing a CLI arg:

- Is it an option or non-option?

  - Option:

    - If it can bind to only one leaf in the Phrase tree, do so.

    - If there are alternatives leaves, collect them and prepare for possible
      backtracking. We will try each leaf in order.

  - Non-option:

    - Is there a current-option that can take args?

      - No: do not bind.
      - Yes, static: just bind.
      - Yes, variable: bind with possible backtracking.

    - Otherwise, we will bind to positional Opts.

      - Static: just bind.
      - Variable: bind with possible backtracking.

--------

## Returned data: nargs, ntimes, etc

General principles:

  - The returned data will have attribute names corresponding to the configured
    Opt instances.

  - ntimes controlls optional/required behavior: is the thing (an option or
    positional) present and, if so, how many times?

  - nargs is straightforward for options: how many args does the option take?

  - For positionals, the nargs/ntimes distinction is not quite as obvious, but
    the optional/required note above points us in the right direction. For
    example:

        frob <x> <y> <y> [<z>]

        opt   nargs   ntimes
        --------------------
        x     1       1       # A typical positional: required with 1 arg.
        y     2       1       # Also required, but 2 args.
        z     1       (0,1)   # Optional, with 1 arg.

        Mnemonic:

            - nargs always counts the number of non-option arguments.

                --foo {} {}     # nargs = 2
                {x} {x}         #

  - In other words, for positionals:

    - Optional/required behavior is governed by ntimes.
    - Positionals always have a nargs of at least 1.
    - Adjacent-repetition of a positional is governed by nargs.

  - Internally, a ParsedOpt will store all values in a 2D array:

      self._values = [
          [a1, a2, ...],  # First time.
          ...             # Etc.
      ]

  - But ParsedOpt.value will return a value flat as possible, based on nargs
    and ntimes (unless user requests non-flattened data). See the examples
    below.

Various nargs-ntimes combos and the returned data:

    nargs | ntimes | data | Note
    ----------------------------
    0     | 0, 1   | .    | .
    0     | 2+     | .    | .
    1     | 0, 1   | .    | .
    1     | 2+     | .    | .
    2+    | 0, 1   | .    | .
    2+    | 2+     | .    | .

  - nargs 0

        # ntimes 0 or 1     # ntimes 2+
        foo: True

                            foo: [                        Flattened
                                True,       First time
                                True,       Second
                                ...         Etc
                            ]

                            foo: [                        Non-flattened
                                [True],
                                [True],
                                ...
                            ]

  - nargs 1

        foo: a1

                            foo: [
                                a1,
                                a2,
                            ]

  - nargs 2+

        foo: [a1, a2, ...]

                            foo: [
                                [a1, a2, a3, ...],
                                [a1, a2, ...],
                                ...
                            ]

Positionals:

  - Example grammar and corresponding params:

        frob (<a> <a> <b> <c>){3} <d> [<e>]

            nargs  ntimes
        -----------------
        a   2      3
        b   1      3
        c   1      3
        d   1      1
        e   1      (0,1)

  - Example usage and returned data:

        frob  10 11 20 30  100 101 200 300  1000 1001 2000 3000  DD

        a: [
            [10, 11],      # First time.
            [100, 101],    # Second time.
            [1000, 1001],  # Third time.
        ],
        b: [
            20,
            200,
            2000,
        ],
        c: [
            30,
            300,
            3000,
        ],
        d: DD
        e: None

--------
Notes formerly in api_design.txt
--------

####
# Parser.
####

p = Parser()

p.parse(args = None)
p.parse_known(args = None)
p.help_text(section = None)
p.error_text()
p.warn(msg)
p.error(code = None, msg = None))
p.exit(code = None, msg = None)

####
# Opts.
####

o = Opt(
    option     = '--job-id',            # Or string-spec with option, aliases, and arg_name.
    aliases    = ['-j', '-J', '--jid'], # Or just one string.
    n_args     = 1,
    repeatable = False,                 # If true, append values.
    choices    = ('A', 'B', 'C', 'D'),
    required   = False,
    tolerant   = False,                 # Setting option makes grammar fully tolerant.
    high       = False,                 # A high-precedence option (eg --help).
    greedy     = True,                  # Affects options arg consumption.
)

####
# Examples.
####

p = Parser(
    # Via simple Opt.
    Opt('--since TERM', type = int, default = 123),
    Opt('--limit N', type = int, default = 0),
    Opt('--rebuild'),
    Opt('--experiment EXP'),
    Opt('--stats'),
    Opt('--month M'),
    Opt('--search TERM', repeatable = True),
    Opt('--get ITEM'),

    # Via full Opts.
    Opt(
        'task',
        choices = 'configure submit upload start get stop download find'.split(),
        desc    = 'The odin-client task to run',
    ),

    # Via dict.
    dict(
        option  = '--odin-env ENV',
        groups  = 'general',
        default = 'dev',
        desc    = "Odin environment ('production' for most users).",
    ),

    parsing_config = {
        allow_abbrev = True,
        opt_prefix_rgx = ...,
    },

    formatter_config = {
        program_name = '...',
        etc ...
    },

)

# All help-text section, in order.
p.help_text()

# Specific help-text sections, in the requested order.
p.help_text('usage')
p.help_text('section-foo')
p.help_text('section-foo', 'section-bar')


####
# SimpleSpec.
####

For example:

    --verbose --type A <x> <y> -h -g

    spec = '-n NAME --foo --bar B1 B2 <x> <y>'
    p = parser(simple = spec)


    expr        = (longoption | shortoption | posarg)+

    longoption  = longopt optarg*
    shortoption = shortopt optarg*
    posarg      = "<" char+ ">"

    longopt     = "--" char+
    shortopt    = "-" char
    optarg      = [A-Z_\-\d]+
    char        = [\w\-]

Elements:

    short opt  | -h
    long opt   | --type
    opt arg    | A
    positional | <x>


Example: from spec to Opt() instances to parsing logic:

    Spec:

        -n NAME --foo --bar B1 B2 <x> <y>

    Opt instances:

        -n      nargs=1
        --foo
        --bar   nargs=2
        x
        y

    Parsing logic:

        # Initial grammar.
        grammar = n | foo | bar | x | y

        # Keep parsing until we have used all grammar elements.
        while grammar.has_elements():
            parse
            if the ParsedOpt we got is not repeatable:
                grammer = grammar - that Opt

####
# GrammarSpec.
####

For references in my notes, let's refer to this example script as blort-maker.

For example:

    general`      : [--verbose] [--log-file {}]
    other`        : [--hi] [--bye]
    help`         : --help* --syntax*

    configure     : general` ; task=configure! --odin-env {} --od-user {}
    submit        : general` ; task=submit! -c {} -r {} [--start-job] [--person {name} {age}]
    get           : general` ; task=get! -j {} [--json [--indent {}] | --b64 | --yaml]
    drop          : general` ; task=drop! what=(first|last|random)! [--print] <n>
    fubb          : [-a] [-b] other` <fubb>... (--fast | --slow)
    zzz           : [-x] [-y] other` (<a> <b> <c> [-z]){2,7}

Naming:

    short opt
    long opt
    opt arg
    positional
    variant
    partial
    destination
    literal
    option group name
    zone

Overall structure:

    foo` : PARTIAL_DEFINITION                               # Use equal sign to mimic BNF?
    bar  : VARIANT_DEFINITION

Variant definition syntax:

    Variants and zones:

        foo`      Insert the "foo" partial definition.
        ;         Divider between zones.                     # Use comma to mimic BNF?
        !         Anchor item(s) to the front of a zone.

    Grouping and alternatives:

        []        Grouping, optional.
        ()        Grouping, required.
        |         Alternation.

    Quantifiers:

        ...       Repetition: 1+ or 0+ depending on brackets or question mark.
        {m,n}     Repetition: m through n, inclusive.
        ?         Non-greedy quantifier.

    Options:

        -x           Short.
        --xy         Long.

    Positional arguments and option arguments:

        <xy>      Positional.
        {xy}      Named option argument.
        {}        Unnamed option argument.

    Literals:

        foo=bar   Literal arg (bar), assigned to "foo" in results.
        bar       Literal arg, not assigned in regults (eg, for separators).
        'bar'     Literal arg, when it conflicts with grammar punctuation.

    Special options:

        *         High precedence option: if present, do a best-effort parse
                  and dispatch to a callable rather that executing the
                  normal program or halting on bad input.

Eager option attachment at repetition boundaries:

    VERDICT: yes. Could be configurable if anyone ever needed.

    - In the `zzz` variant, blort-maker, a sequence of options/positionals can
      be occur 2 to 7 times.

    - If the -z option is provided by the user at a repeated-group boundary,
      we attach it to the first group eagerly.

    - For example:

        # Input.
        A1 B1 C1 -z A2 B2 C2      # -z with first group

        # ParseOption info.
        a : [A1,   A2]
        b : [B1,   B2]
        c : [C1,   C2]
        z : [True, False]

Notes about varying positionals:

    - Only 1 positional can occur a variable N of times.

    - Otherwise, we cannot allocate the values unambiguously.

    - For example, all of these are ambiguous:

        <a>... <b>... <c>
        <a>...{3} <b> <c>...{2} <d>
        (<a> <b>... <c>){2}

    - Varying positionals can be used with an option taking a
      varying nargs, provided that a reasonable parsing approach
      is used and users arrange their command-line arguments
      to avoid ambiguity.

Notes on --help:

    - VERDICT: yes, this plan is reasonable.

    - This example is premised on the idea that we are aiming for
      the following:

        frob --help              # Print general help.
        frob configure --help    # Print help for the configure task.

    - But how does the user configure this help dispatching. More generally,
      what about supporting other help-printing scenarios that rely not on
      `--help` but on some other options: for example, I've had programs where
      I want --examples to print some usage examples for the end-user.

        - Simple use case: standard help feature for a CLI program.

            p = Parser(help = True|False)

        - Help hook for ultimate flexibility: any time the library's help
          feature is triggered, call the user's function with some params and
          let them return something to tell the library which help section to
          print, if any. This approach is probably powerful, but it does not
          speak to simple use cases (standard help) or the most common type of
          complex use case (a program with subcommands, where the subcommands
          and help sections have a 1:1 correspondence).

            p = Parser(help = CALLABLE)

        - To support help dispatching base on subcommands.

            - Simple configuration:

                o = Opt('task', help = USE_SECTIONS)

                - Set the Opt's help param to a constant provided by the
                  library. If set, this tells the library to use the parsed
                  value of the Opt to select the help section whenever help is
                  triggered.

            - More flexible configuration:

                o = Opt('task', help = DICT)

                - The user maps the task values to help section names.

Grammar syntax: named and unnamed arguments:

    Positionals must be named:

        frob <a> <b> [<c>]

    Option arguments can be named or unnamed:

                                            # Value of parsed data in user code:
        frob --mode {group} {name} {n}      # - Data object with attributes.
        frob --mode {} {} {}                # - Tuple.

    Literals can be named or not:

        frob action=div <a> / <b>           # Literal forward slash.

        Unnamed literals won't be in the returned data for now. But support
        could be added later.

Top-level validation: for variants and overall:

    - VERDICT: maybe later.

    - It's not strictly needed, because validators will have contextual
      information about all other Opts.

    - But it could be handy. Without support for overall validation, users must
      do the validation and then call a method to emit the appropriate
      usage/error message to the end-user. With support, the validation just
      needs to return True/False.

Function signature for converters and validators:

    - The defaults:

        Function  | Arity | Signature
        ----------------------------------------------
        Converter | 1     | STR           => OBJ
        Validator | 2     | (PARSER, OBJ) => True/False

    - If needed a future feature:

        Opt(arity = (C, V))   # C and V can be 1 or 2.

Error message configuration:

    - An Opt should be able to control how conversion and/or validation
      failures should be reported.

API needs good syntax for retrieving grammar elements:

    g.get(NAME, NAME, ...)          # Get one.
    g.get(NAME, [NAME, ...], ...)   # Get multiple.

    - Support bulk configuration.

    - In user validation code, they need an easy way to get sibling Opt
      information.

Variants: are they needed?

    - VERDICT: yes for the full grammar. But you don't need it if you have only
      one variant -- no need for pointless variant naming.

    - Why do the variants have names? More broadly, are they really needed if
      we have alternation?

    - Some not-especially-good reasons:

        - Ability to refer to partials by name. This seems true, but
          we could solve partials a different way.

        - Better error reporting. Maybe, but you only need to report info
          about the variant if variants exist.

        - As a convenience for common subcommand use cases, help text could
          be linked to variant names in an automatic way. Maybe, but it
          probably makes more sense to do help-dispatch via the Opt rather
          than the variant.

    - Better reasons:

        - They were useful in the API grammar configuration examples.

        - The name is a useful handle, if nothing else and it might
          be handly later for other features.

Parsing must occur in phases:

    - Phase 1: argument type and conversion:

        - Correct arg type: positional, literal, option, option arg.
        - Conversion success.

    - Phase 2: validation.

Separators:

    VERDICT: grammar already support separators (eg nab).

    - Consider the nab use case.

        - Here we have a linear sequence commands:

            nab grep <> [-c] / split <> <> / item 1 / print

        - Because we don't know in advance what args the commands (grep, split,
          etc) will take, we need a command separator. The command names are
          not sufficient as separators, because some commands might have
          arguments with the same names.

    - How would the user convey the separators in the grammar? I think
      a partial would work:

        - notes elsewhere.

        VERDICT: this works.

    - That seems plausible, but how would returned data be organized?

        - In this case we have a quantified variant? That's new.

        - Two problems:

            VERDICT: not a problem.

            1. We need to link the repeated cmd to a name in the returned data.

            2. And somehow the library needs to know that the first cmd and the
            optional sequence of separator-plus-cmd should be unified under the
            same collection in the returned data.

                ### NOTE: not a problem. It's already the convention elsehwere
                and in my planning notes.

                - Thus, I don't think we need open-ending target assignment
                  for the know use cases.

        - This starts to seem awkward, but the first issue could be solved by
          generalizing the storage-target naming convention we already have.
          Let any element (or group of elements) in the grammar take a target
          name.

            VERDICT: general target assignment not needed

            - For example:

                main : config=([--size {}] [-x] [-z]) run=(<paths>... [--overwrite])

                In returned data:

                    opts.config : Data(size, x, z)
                    opts.run    : Data(paths, overwrite)

            - The nab use case:

                main : commands=(cmd` [ / cmd` ]...)

        - That might work but it's getting very complex visually. It this
          a case where the underlying API should do the work?

Variants: other possible features:

    - Unnamed variants: in the neck-diagram example, the 'main' variant
      isn't doing anything useful.

        VERDICT: it's not required. Smaller parts of the syntax will be used
        elsewhere. The parser needs to handle subsets of the full syntax.

    - Sub-variants.

        VERDICT: supportable, but not now.

        - That might seem like extra complexity, but it might not alter the
          difficulty by very much. We already have a tree-based approach for
          the grammar. Sub-variants just an a new level in the recursion.

        - Do we have any known use cases for subvariants? Not directly,
          but the neck-diagram example is suggestive. For example, take
          neck-diagram as an example, but add more restrictions:

Simple spec vs grammar spec:

    - VERDICT: abandon simple spec. Use the real grammar.

    - Is this separation needed?

    - Just convert simple spec to the official syntax

        # Instead of this.
        -n NAME --foo --bar B1 B2 <x> <y>

        # Do this.
        -n {} --foo --bar {} {} <x> <y>

    - And then allow the grammar to use variants (the complex case) or not.

Grammar syntax and the optionality of pure flags:

    VERDICT: syntax should be explicit about flag optionality.

    - On one hand, a flag option makes no sense being a required
      input. That would imply that syntax diagrams don't need
      square brackets around pure flags.

    - However, the convention appears to show usage syntax in
      explicit terms.

    - In this case, following convention seems wise.

Simplify the tentative syntax plan?

    - VERDICT: no.

    - Retain as archival planning thoughts.

        - Target name assignment for literals:

            for v in ('configure', 'submit', 'get', 'drop'):
                o = g.variants[v].convert_to_literal('configure', 'task')

            - That seems annoying and not intuitive.

            - VERDICT: retain.

        - Boolean OR:

            - This is an easy call: syntax is intuitive and API
              usage for this situation is annoying.

            - VERDICT: retain.

        - Quantifiers.

            - The ... is intuitive and practically a convention.

            - The {m,n} syntax directly mimics regex and is also
              quite intutive.

            - VERDICT: retain.

        - Partials.

            p1 = g.get('general')
            p1.config(partial = True)
            g.get('configure').insert('task', p1)

            - Also annoying: user must make two configurations.

            - And the partial syntax isn't heavy; in fact, I find the
              syntax more intuitive.

            - VERDICT: retain.

        - Zones and anchoring.

            names = ('configure', 'submit', 'get', 'drop')
            get.get(names).insert_zone(anchor = True)

            - API usage seems not too bad.

            - The zone syntax not too obtrusive, and its a mixture of
              intutive (zone) and not intuitive (anchor)

            - However, there' no benefit to supporting zones in syntax
              without anchors.

            - I suspect the desire for zones and anchoring is moderately
              low but still present.

            - VERDICT: retain, but take care to phase the documentation.

        - High precedence.

            g.get(['help', 'syntax']).config(high = True)

            - API is pretty easy.

            - But the syntax is neither heavy nor unintuitive.

            - Syntax is not hard to support.

            - VERDICT: retain.

Sytax example: neck-diagram script:

    - This is a non-standard command line program.

    - But the grammer will handle it fine.

        (
            cmd=snum   <snum>             |
            cmd=fnum   <fnum>             |
            cmd=number numbering=(on|off) |
            cmd=tuning <notes>...         |
            cmd=fret   <syms>...          |
            cmd=invert <syms>...
        )...

Sytax example: nab:

    cmd` :  (
                cmd=chomp                          |
                cmd=findall <rgx>                  |
                cmd=grep <rgx> [-i] [-v] [-s]      |
                cmd=range <start> <stop> [<step>]  |
                cmd=run <code> [-g {}] [-a]
            )

    main : cmd` [ / cmd` ]...

Grammar via API:

    - Defining a grammar with the API is not unreasonable (shown below), but
      it's also verbose, not easily read/scanned, and less intutive that
      the text syntax.

    - Furthermore, the simplicity compounds. Most command-line scripts have
      simple needs. And those simple examples often shine under the syntax. The
      simplest occurs even inside the API usage -- namely, when defining Opt
      instances:

        Opt('--foo {a} {b}')      # Simpler and more powerful.
        Opt('-foo', nargs = 2)

    - That said, I suspect some future grammar features won't fit very easily
      in the syntax. So users need a way to create a grammar with syntax and
      then tweak it with API.

        - An example scenario and variant to illustrate: in order to group opts
          under a child namespace within the returned data (not known to be
          needed yet), we could generalize the target assignment syntax:

                main : config=([--size {}] [-x] [-z]) run=(<paths>... [--overwrite])

        - But that syntax solution is a bit noisy and opaque. An alternative is
          to keep syntax simple and let more complex configuration happen via
          API.

            # Basic syntax:

                main : [--size {}] -x -z <paths>... [--overwrite]

            # Additional API configuration:

                g = Grammar('SYNTAX ...')
                main = g.variants['main']
                main.group('--size', '-x', '-z', target = config)
                main.group('paths', 'overwrite', target = run)

    # The full API usage example:

        general_opts = Partial(
            'general',
            Opt('--verbose'),
            Opt('--log-file {}'),
        )

        other_opts = Partial(
            'other',
            Opt('--hi'),
            Opt('--bye'),
        )

        task_opt = Opt(
            'task',
            choices = ('configure', 'submit', 'get', 'drop'),
        )

        general_zone = Zone(general_opts)

        variants = [
            Variant(
                'configure',
                general_zone,
                Zone(
                    Choice(task_opt, value = 'configure', anchor = True),
                    Opt('--odin-env {}', required = True),
                    Opt('--od-user {}', required = True),
                ),
            ),
            Variant(
                'submit',
                general_zone,
                Zone(
                    Choice(task_opt, value = 'submit', anchor = True),
                    Opt('-c {}', required = True),
                    Opt('-r {}', required = True),
                    Opt('--start-job'),
                    Opt('--person {name} {age}'),
                ),
            ),
            Variant(
                'get',
                general_zone,
                Zone(
                    Choice(task_opt, value = 'get', anchor = True),
                    Opt('-j {}', required = True),
                    Alternatives(
                        Group(
                            Opt('--json', required = True),
                            Opt('--indent {}'),
                        ),
                        Opt('--b64'),
                        Opt('--yaml'),
                        required = False,
                    ),
                ),
            ),
            Variant(
                'drop',
                general_zone,
                Zone(
                    Choice(task_opt, value = 'drop', anchor = True),
                    Opt('what', choices = ('first', 'last', 'random'), required = True),
                    Opt('--print'),
                    Opt('n'),
                ),
            ),
            Variant(
                'fubb',
                Opt('-a'),
                Opt('-b'),
                other_opts,
                Opt('fubb', nargs = (1, None)),
                Alternatives(
                    Opt('--fast'),
                    Opt('--slow'),
                ),
            ),
            Variant(
                'zzz',
                Opt('-x'),
                Opt('-y'),
                other_opts,
                Group(
                    Opt('a'),
                    Opt('b'),
                    Opt('c'),
                    Opt('-z'),
                    ntimes = (2, 7),
                ),
            ),
            Variant(
                'help',
                Opt('--help', high = True),
            ),
        ]

End-user input error scenarios:

    VERDICT: this issue is manageable.

    - Conclusions:

        - Each parse() call will generate up to N failures (one per variant or,
          under the new parsing idea, one per concrete permutation).

        - Ideally, we would report the error most aligned with user intent.

        - Error types can guide that logic. Some errors are specific and
          telling with respect to intent; other tend to be disqualifying. And
          one type of error is so egregrious that intent does not matter.

    - Reporting precendence for errors:

        - First consider error precendence:

            - Global problems.
            - Conversion and validation problems.
            - Structural problems: non-options.
            - Structural problems: options.

        - Then check alignment between arguments and expectations.

            - Greater alignment implies intent.
            - Example metric: N Opts matched / N Opts

        - Finally, use input ordering within the grammar.

        - As a possible future feature, support verbose error reporting,
          triggered by env variables and/or Parser config via API.

    - Types of errors:

        - NOTE: order of the errors is important, but I'm not certain
          what the ordering trait is:

            - Precedence?

            - Specificity? Non-specific errors tend to be disqualifying
              (meaning, the current variant or concrete permutation is probably
              not applicable or intended) and specific errors tend to pull in
              the opposite direction (we know what the user intended, but the
              goofed up a detail).

            - Also, errors related to options are more specific or telling (an
              option is either known, compatible, and allowed ... or not) than
              non-options (which could be positionals or option arguments).

        - Global problems:

            * Errors that are true across all variants and groups. Intent does
              not matter. Reporting an unknown option is both true and helpful.

            - Unknown option: overall.

        - Structural problems: options:

            * Unknown, incompatible, or disallowed options. Compared to
              other error types, these are more disqualifying.

            - Incompatible options: a known option is not in the current
              variant/group. This means it is incompatible with whatever
              argument or option told us which variant/group we are in.

            - Mutually exclusive options: known options both belonging to the
              same Alternation instance.

            - Missing option: required option is not present.

        - Structural problems: non-options:

            * Invalid number of non-option arguments. Due to ambiguities
              between positionals and option arguments under some scenarios,
              these errors are somewhat less specific and more disqualifying
              than structural problems for options.

            - Too few/many arguments for an option (the latter applies when
              supplied grammar has no positionals).

            - Too few/many positionals.

        - Conversion and validation problems:

            * Here we have slotted all arguments into valid slots (none of the
              structure problems listed below), but the actual values don't
              pass muster. These failures are the most specific and telling
              with respect to intent.

            - Option arguments.

            - Positionals.

