--------------------------------------------------------------------------------
contents-and-TCBs: Contents and TCBs
--------------------------------------------------------------------------------

--------
toc: Table of contents
--------

    contents-and-TCBs | Contents and TCBs

        toc              | Table of contents
        misc-new-notes   | Miscellaneous new notes: not yet categorized
        current-TCBs     | Current TCB items
        candidate-TCBs   | Candidate TCB items
        truefire-courses | TrueFire courses
        candidate-notes  | Notes on candidate TCB items

===============================================================




Parsing:

    Organize the code so that it will be able to support:

        regular parsing
        parse known args
        best effort        # Will ignore conversion/validation errors too

Notes on --help:

    - VERDICT: yes, this plan is reasonable.

    - This example is premised on the idea that we are aiming for
      the following:

        frob --help              # Print general help.
        frob configure --help    # Print help for the configure task.

    - But how does the user configure this help dispatching. More generally,
      what about supporting other help-printing scenarios that rely not on
      `--help` but on some other options: for example, I've had programs where
      I want --examples to print some usage examples for the end-user.

        - Simple use case: standard help feature for a command-line program.

            p = Parser(help = True|False)

        - Help hook for ultimate flexibility: any time the library's help
          feature is triggered, call the user's function with some params and
          let them return something to tell the library which help section to
          print, if any. This approach is probably powerful, but it does not
          speak to simple use cases (standard help) or the most common type of
          complex use case (a program with subcommands, where the subcommands
          and help sections have a 1:1 correspondence).

            p = Parser(help = CALLABLE)

        - To support help dispatching base on subcommands.

            - Simple configuration:

                o = Opt('task', help = USE_SECTIONS)

                - Set the Opt's help param to a constant provided by the
                  library. If set, this tells the library to use the parsed
                  value of the Opt to select the help section whenever help is
                  triggered.

            - More flexible configuration:

                o = Opt('task', help = DICT)

                - The user maps the task values to help section names.

End-user input error scenarios:

    VERDICT: this issue is manageable.

    - Conclusions:

        - Each parse() call will generate up to N failures (one per variant or,
          under the new parsing idea, one per concrete permutation).

        - Ideally, we would report the error most aligned with user intent.

        - Error types can guide that logic. Some errors are specific and
          telling with respect to intent; other tend to be disqualifying. And
          one type of error is so egregrious that intent does not matter.

    - Reporting precendence for errors:

        - First consider error precendence:

            - Global problems.
            - Conversion and validation problems.
            - Structural problems: non-options.
            - Structural problems: options.

        - Then check alignment between arguments and expectations.

            - Greater alignment implies intent.
            - Example metric: N Opts matched / N Opts

        - Finally, use input ordering within the grammar.

        - As a possible future feature, support verbose error reporting,
          triggered by env variables and/or Parser config via API.

    - Types of errors:

        - NOTE: order of the errors is important, but I'm not certain
          what the ordering trait is:

            - Precedence?

            - Specificity? Non-specific errors tend to be disqualifying
              (meaning, the current variant or concrete permutation is probably
              not applicable or intended) and specific errors tend to pull in
              the opposite direction (we know what the user intended, but the
              goofed up a detail).

            - Also, errors related to options are more specific or telling (an
              option is either known, compatible, and allowed ... or not) than
              non-options (which could be positionals or option arguments).

        - Global problems:

            * Errors that are true across all variants and groups. Intent does
              not matter. Reporting an unknown option is both true and helpful.

            - Unknown option: overall.

        - Structural problems: options:

            * Unknown, incompatible, or disallowed options. Compared to
              other error types, these are more disqualifying.

            - Incompatible options: a known option is not in the current
              variant/group. This means it is incompatible with whatever
              argument or option told us which variant/group we are in.

            - Mutually exclusive options: known options both belonging to the
              same Alternation instance.

            - Missing option: required option is not present.

        - Structural problems: non-options:

            * Invalid number of non-option arguments. Due to ambiguities
              between positionals and option arguments under some scenarios,
              these errors are somewhat less specific and more disqualifying
              than structural problems for options.

            - Too few/many arguments for an option (the latter applies when
              supplied grammar has no positionals).

            - Too few/many positionals.

        - Conversion and validation problems:

            * Here we have slotted all arguments into valid slots (none of the
              structure problems listed below), but the actual values don't
              pass muster. These failures are the most specific and telling
              with respect to intent.

            - Option arguments.

            - Positionals.

